import { y as w, A as f, e as ir, g as Z, C as Bt, z as ar } from "./index-CtPfqlcy.js";
import { u as De } from "./chunk-K5TMEGOR-DaSvC8Mu.js";
import "./chunk-3MEZQQ2J-CHe_tQrN.js";
import { n as or } from "./chunk-SDMTFDEM-n5DHnLs2.js";
import { n as lr } from "./chunk-6U6BYUHV-TZ4JwLT4.js";
import { D as ur } from "./chunk-MVFOLHBC-BeDRo2V6.js";
import { V as me, a as cr, t as dr } from "./chunk-WG46WHJF-JdNs68CV.js";
w();
w();
w();
w();
w();
var B = class extends Error {
}, hr = class extends B {
  constructor(t) {
    super(`Invalid DateTime: ${t.toMessage()}`);
  }
}, mr = class extends B {
  constructor(t) {
    super(`Invalid Interval: ${t.toMessage()}`);
  }
}, fr = class extends B {
  constructor(t) {
    super(`Invalid Duration: ${t.toMessage()}`);
  }
}, te = class extends B {
}, _t = class extends B {
  constructor(t) {
    super(`Invalid unit ${t}`);
  }
}, M = class extends B {
}, q = class extends B {
  constructor() {
    super("Zone is an abstract class");
  }
};
w();
w();
w();
var c = "numeric", z = "short", $ = "long", je = { year: c, month: c, day: c }, Qt = { year: c, month: z, day: c }, yr = { year: c, month: z, day: c, weekday: z }, Kt = { year: c, month: $, day: c }, Xt = { year: c, month: $, day: c, weekday: $ }, en = { hour: c, minute: c }, tn = { hour: c, minute: c, second: c }, nn = { hour: c, minute: c, second: c, timeZoneName: z }, rn = { hour: c, minute: c, second: c, timeZoneName: $ }, sn = { hour: c, minute: c, hourCycle: "h23" }, an = { hour: c, minute: c, second: c, hourCycle: "h23" }, on = { hour: c, minute: c, second: c, hourCycle: "h23", timeZoneName: z }, ln = { hour: c, minute: c, second: c, hourCycle: "h23", timeZoneName: $ }, un = { year: c, month: c, day: c, hour: c, minute: c }, cn = { year: c, month: c, day: c, hour: c, minute: c, second: c }, dn = { year: c, month: z, day: c, hour: c, minute: c }, hn = { year: c, month: z, day: c, hour: c, minute: c, second: c }, gr = { year: c, month: z, day: c, weekday: z, hour: c, minute: c }, mn = { year: c, month: $, day: c, hour: c, minute: c, timeZoneName: z }, fn = { year: c, month: $, day: c, hour: c, minute: c, second: c, timeZoneName: z }, yn = { year: c, month: $, day: c, weekday: $, hour: c, minute: c, timeZoneName: $ }, gn = { year: c, month: $, day: c, weekday: $, hour: c, minute: c, second: c, timeZoneName: $ };
w();
w();
w();
w();
var Se = class {
  get type() {
    throw new q();
  }
  get name() {
    throw new q();
  }
  get ianaName() {
    return this.name;
  }
  get isUniversal() {
    throw new q();
  }
  offsetName(t, e) {
    throw new q();
  }
  formatOffset(t, e) {
    throw new q();
  }
  offset(t) {
    throw new q();
  }
  equals(t) {
    throw new q();
  }
  get isValid() {
    throw new q();
  }
}, Ge = null, pn = class wn extends Se {
  static get instance() {
    return Ge === null && (Ge = new wn()), Ge;
  }
  get type() {
    return "system";
  }
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  get isUniversal() {
    return !1;
  }
  offsetName(e, { format: n, locale: r }) {
    return Mn(e, n, r);
  }
  formatOffset(e, n) {
    return ve(this.offset(e), n);
  }
  offset(e) {
    return -new Date(e).getTimezoneOffset();
  }
  equals(e) {
    return e.type === "system";
  }
  get isValid() {
    return !0;
  }
};
w();
var Fe = {};
function pr(t) {
  return Fe[t] || (Fe[t] = new Intl.DateTimeFormat("en-US", { hour12: !1, timeZone: t, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", era: "short" })), Fe[t];
}
var wr = { year: 0, month: 1, day: 2, era: 3, hour: 4, minute: 5, second: 6 };
function vr(t, e) {
  let n = t.format(e).replace(/\u200E/g, ""), r = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(n), [, s, i, a, o, l, u, d] = r;
  return [a, s, i, o, l, u, d];
}
function kr(t, e) {
  let n = t.formatToParts(e), r = [];
  for (let s = 0; s < n.length; s++) {
    let { type: i, value: a } = n[s], o = wr[i];
    i === "era" ? r[o] = a : h(o) || (r[o] = parseInt(a, 10));
  }
  return r;
}
var Me = {}, ie = class nt extends Se {
  static create(e) {
    return Me[e] || (Me[e] = new nt(e)), Me[e];
  }
  static resetCache() {
    Me = {}, Fe = {};
  }
  static isValidSpecifier(e) {
    return this.isValidZone(e);
  }
  static isValidZone(e) {
    if (!e) return !1;
    try {
      return new Intl.DateTimeFormat("en-US", { timeZone: e }).format(), !0;
    } catch {
      return !1;
    }
  }
  constructor(e) {
    super(), this.zoneName = e, this.valid = nt.isValidZone(e);
  }
  get type() {
    return "iana";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return !1;
  }
  offsetName(e, { format: n, locale: r }) {
    return Mn(e, n, r, this.name);
  }
  formatOffset(e, n) {
    return ve(this.offset(e), n);
  }
  offset(e) {
    let n = new Date(e);
    if (isNaN(n)) return NaN;
    let r = pr(this.name), [s, i, a, o, l, u, d] = r.formatToParts ? kr(r, n) : vr(r, n);
    o === "BC" && (s = -Math.abs(s) + 1);
    let y = Re({ year: s, month: i, day: a, hour: l === 24 ? 0 : l, minute: u, second: d, millisecond: 0 }), k = +n, m = k % 1e3;
    return k -= m >= 0 ? m : 1e3 + m, (y - k) / (60 * 1e3);
  }
  equals(e) {
    return e.type === "iana" && e.name === this.name;
  }
  get isValid() {
    return this.valid;
  }
};
w();
var vt = {};
function Sr(t, e = {}) {
  let n = JSON.stringify([t, e]), r = vt[n];
  return r || (r = new Intl.ListFormat(t, e), vt[n] = r), r;
}
var rt = {};
function st(t, e = {}) {
  let n = JSON.stringify([t, e]), r = rt[n];
  return r || (r = new Intl.DateTimeFormat(t, e), rt[n] = r), r;
}
var it = {};
function br(t, e = {}) {
  let n = JSON.stringify([t, e]), r = it[n];
  return r || (r = new Intl.NumberFormat(t, e), it[n] = r), r;
}
var at = {};
function Tr(t, e = {}) {
  let n = e, r = Bt(n, ["base"]), s = JSON.stringify([t, r]), i = at[s];
  return i || (i = new Intl.RelativeTimeFormat(t, e), at[s] = i), i;
}
var Le = null;
function Or() {
  return Le || (Le = new Intl.DateTimeFormat().resolvedOptions().locale, Le);
}
var kt = {};
function Nr(t) {
  let e = kt[t];
  if (!e) {
    let n = new Intl.Locale(t);
    e = "getWeekInfo" in n ? n.getWeekInfo() : n.weekInfo, kt[t] = e;
  }
  return e;
}
function Dr(t) {
  let e = t.indexOf("-x-");
  e !== -1 && (t = t.substring(0, e));
  let n = t.indexOf("-u-");
  if (n === -1) return [t];
  {
    let r, s;
    try {
      r = st(t).resolvedOptions(), s = t;
    } catch {
      let l = t.substring(0, n);
      r = st(l).resolvedOptions(), s = l;
    }
    let { numberingSystem: i, calendar: a } = r;
    return [s, i, a];
  }
}
function Mr(t, e, n) {
  return (n || e) && (t.includes("-u-") || (t += "-u"), n && (t += `-ca-${n}`), e && (t += `-nu-${e}`)), t;
}
function Er(t) {
  let e = [];
  for (let n = 1; n <= 12; n++) {
    let r = b.utc(2009, n, 1);
    e.push(t(r));
  }
  return e;
}
function $r(t) {
  let e = [];
  for (let n = 1; n <= 7; n++) {
    let r = b.utc(2016, 11, 13 + n);
    e.push(t(r));
  }
  return e;
}
function Ee(t, e, n, r) {
  let s = t.listingMode();
  return s === "error" ? null : s === "en" ? n(e) : r(e);
}
function Cr(t) {
  return t.numberingSystem && t.numberingSystem !== "latn" ? !1 : t.numberingSystem === "latn" || !t.locale || t.locale.startsWith("en") || new Intl.DateTimeFormat(t.intl).resolvedOptions().numberingSystem === "latn";
}
var Ir = class {
  constructor(t, e, n) {
    this.padTo = n.padTo || 0, this.floor = n.floor || !1;
    let r = n, s = Bt(r, ["padTo", "floor"]);
    if (!e || Object.keys(s).length > 0) {
      let i = f({ useGrouping: !1 }, n);
      n.padTo > 0 && (i.minimumIntegerDigits = n.padTo), this.inf = br(t, i);
    }
  }
  format(t) {
    if (this.inf) {
      let e = this.floor ? Math.floor(t) : t;
      return this.inf.format(e);
    } else {
      let e = this.floor ? Math.floor(t) : mt(t, 3);
      return T(e, this.padTo);
    }
  }
}, xr = class {
  constructor(t, e, n) {
    this.opts = n, this.originalZone = void 0;
    let r;
    if (this.opts.timeZone) this.dt = t;
    else if (t.zone.type === "fixed") {
      let i = -1 * (t.offset / 60), a = i >= 0 ? `Etc/GMT+${i}` : `Etc/GMT${i}`;
      t.offset !== 0 && ie.create(a).valid ? (r = a, this.dt = t) : (r = "UTC", this.dt = t.offset === 0 ? t : t.setZone("UTC").plus({ minutes: t.offset }), this.originalZone = t.zone);
    } else t.zone.type === "system" ? this.dt = t : t.zone.type === "iana" ? (this.dt = t, r = t.zone.name) : (r = "UTC", this.dt = t.setZone("UTC").plus({ minutes: t.offset }), this.originalZone = t.zone);
    let s = f({}, this.opts);
    s.timeZone = s.timeZone || r, this.dtf = st(e, s);
  }
  format() {
    return this.originalZone ? this.formatToParts().map(({ value: t }) => t).join("") : this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    let t = this.dtf.formatToParts(this.dt.toJSDate());
    return this.originalZone ? t.map((e) => {
      if (e.type === "timeZoneName") {
        let n = this.originalZone.offsetName(this.dt.ts, { locale: this.dt.locale, format: this.opts.timeZoneName });
        return Z(f({}, e), { value: n });
      } else return e;
    }) : t;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}, Vr = class {
  constructor(t, e, n) {
    this.opts = f({ style: "long" }, n), !e && Nn() && (this.rtf = Tr(t, n));
  }
  format(t, e) {
    return this.rtf ? this.rtf.format(t, e) : ns(e, t, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(t, e) {
    return this.rtf ? this.rtf.formatToParts(t, e) : [];
  }
}, Fr = { firstDay: 1, minimalDays: 4, weekend: [6, 7] }, p = class ye {
  static fromOpts(e) {
    return ye.create(e.locale, e.numberingSystem, e.outputCalendar, e.weekSettings, e.defaultToEN);
  }
  static create(e, n, r, s, i = !1) {
    let a = e || S.defaultLocale, o = a || (i ? "en-US" : Or()), l = n || S.defaultNumberingSystem, u = r || S.defaultOutputCalendar, d = ot(s) || S.defaultWeekSettings;
    return new ye(o, l, u, d, a);
  }
  static resetCache() {
    Le = null, rt = {}, it = {}, at = {};
  }
  static fromObject({ locale: e, numberingSystem: n, outputCalendar: r, weekSettings: s } = {}) {
    return ye.create(e, n, r, s);
  }
  constructor(e, n, r, s, i) {
    let [a, o, l] = Dr(e);
    this.locale = a, this.numberingSystem = n || o || null, this.outputCalendar = r || l || null, this.weekSettings = s, this.intl = Mr(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = i, this.fastNumbersCached = null;
  }
  get fastNumbers() {
    return this.fastNumbersCached == null && (this.fastNumbersCached = Cr(this)), this.fastNumbersCached;
  }
  listingMode() {
    let e = this.isEnglish(), n = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return e && n ? "en" : "intl";
  }
  clone(e) {
    return !e || Object.getOwnPropertyNames(e).length === 0 ? this : ye.create(e.locale || this.specifiedLocale, e.numberingSystem || this.numberingSystem, e.outputCalendar || this.outputCalendar, ot(e.weekSettings) || this.weekSettings, e.defaultToEN || !1);
  }
  redefaultToEN(e = {}) {
    return this.clone(Z(f({}, e), { defaultToEN: !0 }));
  }
  redefaultToSystem(e = {}) {
    return this.clone(Z(f({}, e), { defaultToEN: !1 }));
  }
  months(e, n = !1) {
    return Ee(this, e, Cn, () => {
      let r = n ? { month: e, day: "numeric" } : { month: e }, s = n ? "format" : "standalone";
      return this.monthsCache[s][e] || (this.monthsCache[s][e] = Er((i) => this.extract(i, r, "month"))), this.monthsCache[s][e];
    });
  }
  weekdays(e, n = !1) {
    return Ee(this, e, Vn, () => {
      let r = n ? { weekday: e, year: "numeric", month: "long", day: "numeric" } : { weekday: e }, s = n ? "format" : "standalone";
      return this.weekdaysCache[s][e] || (this.weekdaysCache[s][e] = $r((i) => this.extract(i, r, "weekday"))), this.weekdaysCache[s][e];
    });
  }
  meridiems() {
    return Ee(this, void 0, () => Fn, () => {
      if (!this.meridiemCache) {
        let e = { hour: "numeric", hourCycle: "h12" };
        this.meridiemCache = [b.utc(2016, 11, 13, 9), b.utc(2016, 11, 13, 19)].map((n) => this.extract(n, e, "dayperiod"));
      }
      return this.meridiemCache;
    });
  }
  eras(e) {
    return Ee(this, e, Ln, () => {
      let n = { era: e };
      return this.eraCache[e] || (this.eraCache[e] = [b.utc(-40, 1, 1), b.utc(2017, 1, 1)].map((r) => this.extract(r, n, "era"))), this.eraCache[e];
    });
  }
  extract(e, n, r) {
    let s = this.dtFormatter(e, n), i = s.formatToParts(), a = i.find((o) => o.type.toLowerCase() === r);
    return a ? a.value : null;
  }
  numberFormatter(e = {}) {
    return new Ir(this.intl, e.forceSimple || this.fastNumbers, e);
  }
  dtFormatter(e, n = {}) {
    return new xr(e, this.intl, n);
  }
  relFormatter(e = {}) {
    return new Vr(this.intl, this.isEnglish(), e);
  }
  listFormatter(e = {}) {
    return Sr(this.intl, e);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  getWeekSettings() {
    return this.weekSettings ? this.weekSettings : Dn() ? Nr(this.locale) : Fr;
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(e) {
    return this.locale === e.locale && this.numberingSystem === e.numberingSystem && this.outputCalendar === e.outputCalendar;
  }
  toString() {
    return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;
  }
};
w();
w();
var Be = null, A = class ge extends Se {
  static get utcInstance() {
    return Be === null && (Be = new ge(0)), Be;
  }
  static instance(e) {
    return e === 0 ? ge.utcInstance : new ge(e);
  }
  static parseSpecifier(e) {
    if (e) {
      let n = e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (n) return new ge(Pe(n[1], n[2]));
    }
    return null;
  }
  constructor(e) {
    super(), this.fixed = e;
  }
  get type() {
    return "fixed";
  }
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${ve(this.fixed, "narrow")}`;
  }
  get ianaName() {
    return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${ve(-this.fixed, "narrow")}`;
  }
  offsetName() {
    return this.name;
  }
  formatOffset(e, n) {
    return ve(this.fixed, n);
  }
  get isUniversal() {
    return !0;
  }
  offset() {
    return this.fixed;
  }
  equals(e) {
    return e.type === "fixed" && e.fixed === this.fixed;
  }
  get isValid() {
    return !0;
  }
};
w();
var Lr = class extends Se {
  constructor(t) {
    super(), this.zoneName = t;
  }
  get type() {
    return "invalid";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return !1;
  }
  offsetName() {
    return null;
  }
  formatOffset() {
    return "";
  }
  offset() {
    return NaN;
  }
  equals() {
    return !1;
  }
  get isValid() {
    return !1;
  }
};
function H(t, e) {
  if (h(t) || t === null) return e;
  if (t instanceof Se) return t;
  if (qr(t)) {
    let n = t.toLowerCase();
    return n === "default" ? e : n === "local" || n === "system" ? pn.instance : n === "utc" || n === "gmt" ? A.utcInstance : A.parseSpecifier(n) || ie.create(t);
  } else return R(t) ? A.instance(t) : typeof t == "object" && "offset" in t && typeof t.offset == "function" ? t : new Lr(t);
}
w();
var ut = { arab: "[٠-٩]", arabext: "[۰-۹]", bali: "[᭐-᭙]", beng: "[০-৯]", deva: "[०-९]", fullwide: "[０-９]", gujr: "[૦-૯]", hanidec: "[〇|一|二|三|四|五|六|七|八|九]", khmr: "[០-៩]", knda: "[೦-೯]", laoo: "[໐-໙]", limb: "[᥆-᥏]", mlym: "[൦-൯]", mong: "[᠐-᠙]", mymr: "[၀-၉]", orya: "[୦-୯]", tamldec: "[௦-௯]", telu: "[౦-౯]", thai: "[๐-๙]", tibt: "[༠-༩]", latn: "\\d" }, St = { arab: [1632, 1641], arabext: [1776, 1785], bali: [6992, 7001], beng: [2534, 2543], deva: [2406, 2415], fullwide: [65296, 65303], gujr: [2790, 2799], khmr: [6112, 6121], knda: [3302, 3311], laoo: [3792, 3801], limb: [6470, 6479], mlym: [3430, 3439], mong: [6160, 6169], mymr: [4160, 4169], orya: [2918, 2927], tamldec: [3046, 3055], telu: [3174, 3183], thai: [3664, 3673], tibt: [3872, 3881] }, Wr = ut.hanidec.replace(/[\[|\]]/g, "").split("");
function Zr(t) {
  let e = parseInt(t, 10);
  if (isNaN(e)) {
    e = "";
    for (let n = 0; n < t.length; n++) {
      let r = t.charCodeAt(n);
      if (t[n].search(ut.hanidec) !== -1) e += Wr.indexOf(t[n]);
      else for (let s in St) {
        let [i, a] = St[s];
        r >= i && r <= a && (e += r - i);
      }
    }
    return parseInt(e, 10);
  } else return e;
}
var ee = {};
function zr() {
  ee = {};
}
function V({ numberingSystem: t }, e = "") {
  let n = t || "latn";
  return ee[n] || (ee[n] = {}), ee[n][e] || (ee[n][e] = new RegExp(`${ut[n]}${e}`)), ee[n][e];
}
var bt = () => Date.now(), Tt = "system", Ot = null, Nt = null, Dt = null, Mt = 60, Et, $t = null, S = class {
  static get now() {
    return bt;
  }
  static set now(t) {
    bt = t;
  }
  static set defaultZone(t) {
    Tt = t;
  }
  static get defaultZone() {
    return H(Tt, pn.instance);
  }
  static get defaultLocale() {
    return Ot;
  }
  static set defaultLocale(t) {
    Ot = t;
  }
  static get defaultNumberingSystem() {
    return Nt;
  }
  static set defaultNumberingSystem(t) {
    Nt = t;
  }
  static get defaultOutputCalendar() {
    return Dt;
  }
  static set defaultOutputCalendar(t) {
    Dt = t;
  }
  static get defaultWeekSettings() {
    return $t;
  }
  static set defaultWeekSettings(t) {
    $t = ot(t);
  }
  static get twoDigitCutoffYear() {
    return Mt;
  }
  static set twoDigitCutoffYear(t) {
    Mt = t % 100;
  }
  static get throwOnInvalid() {
    return Et;
  }
  static set throwOnInvalid(t) {
    Et = t;
  }
  static resetCaches() {
    p.resetCache(), ie.resetCache(), b.resetCache(), zr();
  }
};
w();
w();
var W = class {
  constructor(t, e) {
    this.reason = t, this.explanation = e;
  }
  toMessage() {
    return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason;
  }
}, vn = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], kn = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function I(t, e) {
  return new W("unit out of range", `you specified ${e} (of type ${typeof e}) as a ${t}, which is invalid`);
}
function ct(t, e, n) {
  let r = new Date(Date.UTC(t, e - 1, n));
  t < 100 && t >= 0 && r.setUTCFullYear(r.getUTCFullYear() - 1900);
  let s = r.getUTCDay();
  return s === 0 ? 7 : s;
}
function Sn(t, e, n) {
  return n + (be(t) ? kn : vn)[e - 1];
}
function bn(t, e) {
  let n = be(t) ? kn : vn, r = n.findIndex((i) => i < e), s = e - n[r];
  return { month: r + 1, day: s };
}
function dt(t, e) {
  return (t - e + 7) % 7 + 1;
}
function qe(t, e = 4, n = 1) {
  let { year: r, month: s, day: i } = t, a = Sn(r, s, i), o = dt(ct(r, s, i), n), l = Math.floor((a - o + 14 - e) / 7), u;
  return l < 1 ? (u = r - 1, l = ke(u, e, n)) : l > ke(r, e, n) ? (u = r + 1, l = 1) : u = r, f({ weekYear: u, weekNumber: l, weekday: o }, Je(t));
}
function Ct(t, e = 4, n = 1) {
  let { weekYear: r, weekNumber: s, weekday: i } = t, a = dt(ct(r, 1, e), n), o = ne(r), l = s * 7 + i - a - 7 + e, u;
  l < 1 ? (u = r - 1, l += ne(u)) : l > o ? (u = r + 1, l -= ne(r)) : u = r;
  let { month: d, day: y } = bn(u, l);
  return f({ year: u, month: d, day: y }, Je(t));
}
function _e(t) {
  let { year: e, month: n, day: r } = t, s = Sn(e, n, r);
  return f({ year: e, ordinal: s }, Je(t));
}
function It(t) {
  let { year: e, ordinal: n } = t, { month: r, day: s } = bn(e, n);
  return f({ year: e, month: r, day: s }, Je(t));
}
function xt(t, e) {
  if (!h(t.localWeekday) || !h(t.localWeekNumber) || !h(t.localWeekYear)) {
    if (!h(t.weekday) || !h(t.weekNumber) || !h(t.weekYear)) throw new te("Cannot mix locale-based week fields with ISO-based week fields");
    return h(t.localWeekday) || (t.weekday = t.localWeekday), h(t.localWeekNumber) || (t.weekNumber = t.localWeekNumber), h(t.localWeekYear) || (t.weekYear = t.localWeekYear), delete t.localWeekday, delete t.localWeekNumber, delete t.localWeekYear, { minDaysInFirstWeek: e.getMinDaysInFirstWeek(), startOfWeek: e.getStartOfWeek() };
  } else return { minDaysInFirstWeek: 4, startOfWeek: 1 };
}
function Ar(t, e = 4, n = 1) {
  let r = He(t.weekYear), s = x(t.weekNumber, 1, ke(t.weekYear, e, n)), i = x(t.weekday, 1, 7);
  return r ? s ? i ? !1 : I("weekday", t.weekday) : I("week", t.weekNumber) : I("weekYear", t.weekYear);
}
function jr(t) {
  let e = He(t.year), n = x(t.ordinal, 1, ne(t.year));
  return e ? n ? !1 : I("ordinal", t.ordinal) : I("year", t.year);
}
function Tn(t) {
  let e = He(t.year), n = x(t.month, 1, 12), r = x(t.day, 1, Ue(t.year, t.month));
  return e ? n ? r ? !1 : I("day", t.day) : I("month", t.month) : I("year", t.year);
}
function On(t) {
  let { hour: e, minute: n, second: r, millisecond: s } = t, i = x(e, 0, 23) || e === 24 && n === 0 && r === 0 && s === 0, a = x(n, 0, 59), o = x(r, 0, 59), l = x(s, 0, 999);
  return i ? a ? o ? l ? !1 : I("millisecond", s) : I("second", r) : I("minute", n) : I("hour", e);
}
function h(t) {
  return typeof t > "u";
}
function R(t) {
  return typeof t == "number";
}
function He(t) {
  return typeof t == "number" && t % 1 === 0;
}
function qr(t) {
  return typeof t == "string";
}
function Ur(t) {
  return Object.prototype.toString.call(t) === "[object Date]";
}
function Nn() {
  try {
    return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
  } catch {
    return !1;
  }
}
function Dn() {
  try {
    return typeof Intl < "u" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch {
    return !1;
  }
}
function Yr(t) {
  return Array.isArray(t) ? t : [t];
}
function Vt(t, e, n) {
  if (t.length !== 0) return t.reduce((r, s) => {
    let i = [e(s), s];
    return r && n(r[0], i[0]) === r[0] ? r : i;
  }, null)[1];
}
function Hr(t, e) {
  return e.reduce((n, r) => (n[r] = t[r], n), {});
}
function se(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function ot(t) {
  if (t == null) return null;
  if (typeof t != "object") throw new M("Week settings must be an object");
  if (!x(t.firstDay, 1, 7) || !x(t.minimalDays, 1, 7) || !Array.isArray(t.weekend) || t.weekend.some((e) => !x(e, 1, 7))) throw new M("Invalid week settings");
  return { firstDay: t.firstDay, minimalDays: t.minimalDays, weekend: Array.from(t.weekend) };
}
function x(t, e, n) {
  return He(t) && t >= e && t <= n;
}
function Rr(t, e) {
  return t - e * Math.floor(t / e);
}
function T(t, e = 2) {
  let n = t < 0, r;
  return n ? r = "-" + ("" + -t).padStart(e, "0") : r = ("" + t).padStart(e, "0"), r;
}
function Y(t) {
  if (!(h(t) || t === null || t === "")) return parseInt(t, 10);
}
function P(t) {
  if (!(h(t) || t === null || t === "")) return parseFloat(t);
}
function ht(t) {
  if (!(h(t) || t === null || t === "")) {
    let e = parseFloat("0." + t) * 1e3;
    return Math.floor(e);
  }
}
function mt(t, e, n = !1) {
  let r = ar(10, e);
  return (n ? Math.trunc : Math.round)(t * r) / r;
}
function be(t) {
  return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0);
}
function ne(t) {
  return be(t) ? 366 : 365;
}
function Ue(t, e) {
  let n = Rr(e - 1, 12) + 1, r = t + (e - n) / 12;
  return n === 2 ? be(r) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][n - 1];
}
function Re(t) {
  let e = Date.UTC(t.year, t.month - 1, t.day, t.hour, t.minute, t.second, t.millisecond);
  return t.year < 100 && t.year >= 0 && (e = new Date(e), e.setUTCFullYear(t.year, t.month - 1, t.day)), +e;
}
function Ft(t, e, n) {
  return -dt(ct(t, 1, e), n) + e - 1;
}
function ke(t, e = 4, n = 1) {
  let r = Ft(t, e, n), s = Ft(t + 1, e, n);
  return (ne(t) - r + s) / 7;
}
function lt(t) {
  return t > 99 ? t : t > S.twoDigitCutoffYear ? 1900 + t : 2e3 + t;
}
function Mn(t, e, n, r = null) {
  let s = new Date(t), i = { hourCycle: "h23", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit" };
  r && (i.timeZone = r);
  let a = f({ timeZoneName: e }, i), o = new Intl.DateTimeFormat(n, a).formatToParts(s).find((l) => l.type.toLowerCase() === "timezonename");
  return o ? o.value : null;
}
function Pe(t, e) {
  let n = parseInt(t, 10);
  Number.isNaN(n) && (n = 0);
  let r = parseInt(e, 10) || 0, s = n < 0 || Object.is(n, -0) ? -r : r;
  return n * 60 + s;
}
function En(t) {
  let e = Number(t);
  if (typeof t == "boolean" || t === "" || Number.isNaN(e)) throw new M(`Invalid unit value ${t}`);
  return e;
}
function Ye(t, e) {
  let n = {};
  for (let r in t) if (se(t, r)) {
    let s = t[r];
    if (s == null) continue;
    n[e(r)] = En(s);
  }
  return n;
}
function ve(t, e) {
  let n = Math.trunc(Math.abs(t / 60)), r = Math.trunc(Math.abs(t % 60)), s = t >= 0 ? "+" : "-";
  switch (e) {
    case "short":
      return `${s}${T(n, 2)}:${T(r, 2)}`;
    case "narrow":
      return `${s}${n}${r > 0 ? `:${r}` : ""}`;
    case "techie":
      return `${s}${T(n, 2)}${T(r, 2)}`;
    default:
      throw new RangeError(`Value format ${e} is out of range for property format`);
  }
}
function Je(t) {
  return Hr(t, ["hour", "minute", "second", "millisecond"]);
}
var Pr = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], $n = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], Jr = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function Cn(t) {
  switch (t) {
    case "narrow":
      return [...Jr];
    case "short":
      return [...$n];
    case "long":
      return [...Pr];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
var In = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], xn = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], Gr = ["M", "T", "W", "T", "F", "S", "S"];
function Vn(t) {
  switch (t) {
    case "narrow":
      return [...Gr];
    case "short":
      return [...xn];
    case "long":
      return [...In];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
var Fn = ["AM", "PM"], Br = ["Before Christ", "Anno Domini"], _r = ["BC", "AD"], Qr = ["B", "A"];
function Ln(t) {
  switch (t) {
    case "narrow":
      return [...Qr];
    case "short":
      return [..._r];
    case "long":
      return [...Br];
    default:
      return null;
  }
}
function Kr(t) {
  return Fn[t.hour < 12 ? 0 : 1];
}
function Xr(t, e) {
  return Vn(e)[t.weekday - 1];
}
function es(t, e) {
  return Cn(e)[t.month - 1];
}
function ts(t, e) {
  return Ln(e)[t.year < 0 ? 0 : 1];
}
function ns(t, e, n = "always", r = !1) {
  let s = { years: ["year", "yr."], quarters: ["quarter", "qtr."], months: ["month", "mo."], weeks: ["week", "wk."], days: ["day", "day", "days"], hours: ["hour", "hr."], minutes: ["minute", "min."], seconds: ["second", "sec."] }, i = ["hours", "minutes", "seconds"].indexOf(t) === -1;
  if (n === "auto" && i) {
    let y = t === "days";
    switch (e) {
      case 1:
        return y ? "tomorrow" : `next ${s[t][0]}`;
      case -1:
        return y ? "yesterday" : `last ${s[t][0]}`;
      case 0:
        return y ? "today" : `this ${s[t][0]}`;
    }
  }
  let a = Object.is(e, -0) || e < 0, o = Math.abs(e), l = o === 1, u = s[t], d = r ? l ? u[1] : u[2] || u[1] : l ? s[t][0] : t;
  return a ? `${o} ${d} ago` : `in ${o} ${d}`;
}
function Lt(t, e) {
  let n = "";
  for (let r of t) r.literal ? n += r.val : n += e(r.val);
  return n;
}
var rs = { D: je, DD: Qt, DDD: Kt, DDDD: Xt, t: en, tt: tn, ttt: nn, tttt: rn, T: sn, TT: an, TTT: on, TTTT: ln, f: un, ff: dn, fff: mn, ffff: yn, F: cn, FF: hn, FFF: fn, FFFF: gn }, L = class pe {
  static create(e, n = {}) {
    return new pe(e, n);
  }
  static parseFormat(e) {
    let n = null, r = "", s = !1, i = [];
    for (let a = 0; a < e.length; a++) {
      let o = e.charAt(a);
      o === "'" ? (r.length > 0 && i.push({ literal: s || /^\s+$/.test(r), val: r }), n = null, r = "", s = !s) : s || o === n ? r += o : (r.length > 0 && i.push({ literal: /^\s+$/.test(r), val: r }), r = o, n = o);
    }
    return r.length > 0 && i.push({ literal: s || /^\s+$/.test(r), val: r }), i;
  }
  static macroTokenToFormatOpts(e) {
    return rs[e];
  }
  constructor(e, n) {
    this.opts = n, this.loc = e, this.systemLoc = null;
  }
  formatWithSystemDefault(e, n) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(e, f(f({}, this.opts), n)).format();
  }
  dtFormatter(e, n = {}) {
    return this.loc.dtFormatter(e, f(f({}, this.opts), n));
  }
  formatDateTime(e, n) {
    return this.dtFormatter(e, n).format();
  }
  formatDateTimeParts(e, n) {
    return this.dtFormatter(e, n).formatToParts();
  }
  formatInterval(e, n) {
    return this.dtFormatter(e.start, n).dtf.formatRange(e.start.toJSDate(), e.end.toJSDate());
  }
  resolvedOptions(e, n) {
    return this.dtFormatter(e, n).resolvedOptions();
  }
  num(e, n = 0) {
    if (this.opts.forceSimple) return T(e, n);
    let r = f({}, this.opts);
    return n > 0 && (r.padTo = n), this.loc.numberFormatter(r).format(e);
  }
  formatDateTimeFromString(e, n) {
    let r = this.loc.listingMode() === "en", s = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", i = (m, D) => this.loc.extract(e, m, D), a = (m) => e.isOffsetFixed && e.offset === 0 && m.allowZ ? "Z" : e.isValid ? e.zone.formatOffset(e.ts, m.format) : "", o = () => r ? Kr(e) : i({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), l = (m, D) => r ? es(e, m) : i(D ? { month: m } : { month: m, day: "numeric" }, "month"), u = (m, D) => r ? Xr(e, m) : i(D ? { weekday: m } : { weekday: m, month: "long", day: "numeric" }, "weekday"), d = (m) => {
      let D = pe.macroTokenToFormatOpts(m);
      return D ? this.formatWithSystemDefault(e, D) : m;
    }, y = (m) => r ? ts(e, m) : i({ era: m }, "era"), k = (m) => {
      switch (m) {
        case "S":
          return this.num(e.millisecond);
        case "u":
        case "SSS":
          return this.num(e.millisecond, 3);
        case "s":
          return this.num(e.second);
        case "ss":
          return this.num(e.second, 2);
        case "uu":
          return this.num(Math.floor(e.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(e.millisecond / 100));
        case "m":
          return this.num(e.minute);
        case "mm":
          return this.num(e.minute, 2);
        case "h":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12);
        case "hh":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12, 2);
        case "H":
          return this.num(e.hour);
        case "HH":
          return this.num(e.hour, 2);
        case "Z":
          return a({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return a({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return a({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return e.zone.offsetName(e.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return e.zone.offsetName(e.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return e.zoneName;
        case "a":
          return o();
        case "d":
          return s ? i({ day: "numeric" }, "day") : this.num(e.day);
        case "dd":
          return s ? i({ day: "2-digit" }, "day") : this.num(e.day, 2);
        case "c":
          return this.num(e.weekday);
        case "ccc":
          return u("short", !0);
        case "cccc":
          return u("long", !0);
        case "ccccc":
          return u("narrow", !0);
        case "E":
          return this.num(e.weekday);
        case "EEE":
          return u("short", !1);
        case "EEEE":
          return u("long", !1);
        case "EEEEE":
          return u("narrow", !1);
        case "L":
          return s ? i({ month: "numeric", day: "numeric" }, "month") : this.num(e.month);
        case "LL":
          return s ? i({ month: "2-digit", day: "numeric" }, "month") : this.num(e.month, 2);
        case "LLL":
          return l("short", !0);
        case "LLLL":
          return l("long", !0);
        case "LLLLL":
          return l("narrow", !0);
        case "M":
          return s ? i({ month: "numeric" }, "month") : this.num(e.month);
        case "MM":
          return s ? i({ month: "2-digit" }, "month") : this.num(e.month, 2);
        case "MMM":
          return l("short", !1);
        case "MMMM":
          return l("long", !1);
        case "MMMMM":
          return l("narrow", !1);
        case "y":
          return s ? i({ year: "numeric" }, "year") : this.num(e.year);
        case "yy":
          return s ? i({ year: "2-digit" }, "year") : this.num(e.year.toString().slice(-2), 2);
        case "yyyy":
          return s ? i({ year: "numeric" }, "year") : this.num(e.year, 4);
        case "yyyyyy":
          return s ? i({ year: "numeric" }, "year") : this.num(e.year, 6);
        case "G":
          return y("short");
        case "GG":
          return y("long");
        case "GGGGG":
          return y("narrow");
        case "kk":
          return this.num(e.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(e.weekYear, 4);
        case "W":
          return this.num(e.weekNumber);
        case "WW":
          return this.num(e.weekNumber, 2);
        case "n":
          return this.num(e.localWeekNumber);
        case "nn":
          return this.num(e.localWeekNumber, 2);
        case "ii":
          return this.num(e.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(e.localWeekYear, 4);
        case "o":
          return this.num(e.ordinal);
        case "ooo":
          return this.num(e.ordinal, 3);
        case "q":
          return this.num(e.quarter);
        case "qq":
          return this.num(e.quarter, 2);
        case "X":
          return this.num(Math.floor(e.ts / 1e3));
        case "x":
          return this.num(e.ts);
        default:
          return d(m);
      }
    };
    return Lt(pe.parseFormat(n), k);
  }
  formatDurationFromString(e, n) {
    let r = (l) => {
      switch (l[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, s = (l) => (u) => {
      let d = r(u);
      return d ? this.num(l.get(d), u.length) : u;
    }, i = pe.parseFormat(n), a = i.reduce((l, { literal: u, val: d }) => u ? l : l.concat(d), []), o = e.shiftTo(...a.map(r).filter((l) => l));
    return Lt(i, s(o));
  }
};
w();
var Wn = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function ae(...t) {
  let e = t.reduce((n, r) => n + r.source, "");
  return RegExp(`^${e}$`);
}
function oe(...t) {
  return (e) => t.reduce(([n, r, s], i) => {
    let [a, o, l] = i(e, s);
    return [f(f({}, n), a), o || r, l];
  }, [{}, null, 1]).slice(0, 2);
}
function le(t, ...e) {
  if (t == null) return [null, null];
  for (let [n, r] of e) {
    let s = n.exec(t);
    if (s) return r(s);
  }
  return [null, null];
}
function Zn(...t) {
  return (e, n) => {
    let r = {}, s;
    for (s = 0; s < t.length; s++) r[t[s]] = Y(e[n + s]);
    return [r, null, n + s];
  };
}
var zn = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, ss = `(?:${zn.source}?(?:\\[(${Wn.source})\\])?)?`, ft = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, An = RegExp(`${ft.source}${ss}`), yt = RegExp(`(?:T${An.source})?`), is = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, as = /(\d{4})-?W(\d\d)(?:-?(\d))?/, os = /(\d{4})-?(\d{3})/, ls = Zn("weekYear", "weekNumber", "weekDay"), us = Zn("year", "ordinal"), cs = /(\d{4})-(\d\d)-(\d\d)/, jn = RegExp(`${ft.source} ?(?:${zn.source}|(${Wn.source}))?`), ds = RegExp(`(?: ${jn.source})?`);
function re(t, e, n) {
  let r = t[e];
  return h(r) ? n : Y(r);
}
function hs(t, e) {
  return [{ year: re(t, e), month: re(t, e + 1, 1), day: re(t, e + 2, 1) }, null, e + 3];
}
function ue(t, e) {
  return [{ hours: re(t, e, 0), minutes: re(t, e + 1, 0), seconds: re(t, e + 2, 0), milliseconds: ht(t[e + 3]) }, null, e + 4];
}
function Te(t, e) {
  let n = !t[e] && !t[e + 1], r = Pe(t[e + 1], t[e + 2]), s = n ? null : A.instance(r);
  return [{}, s, e + 3];
}
function Oe(t, e) {
  let n = t[e] ? ie.create(t[e]) : null;
  return [{}, n, e + 1];
}
var ms = RegExp(`^T?${ft.source}$`), fs = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function ys(t) {
  let [e, n, r, s, i, a, o, l, u] = t, d = e[0] === "-", y = l && l[0] === "-", k = (m, D = !1) => m !== void 0 && (D || m && d) ? -m : m;
  return [{ years: k(P(n)), months: k(P(r)), weeks: k(P(s)), days: k(P(i)), hours: k(P(a)), minutes: k(P(o)), seconds: k(P(l), l === "-0"), milliseconds: k(ht(u), y) }];
}
var gs = { GMT: 0, EDT: -4 * 60, EST: -5 * 60, CDT: -5 * 60, CST: -6 * 60, MDT: -6 * 60, MST: -7 * 60, PDT: -7 * 60, PST: -8 * 60 };
function gt(t, e, n, r, s, i, a) {
  let o = { year: e.length === 2 ? lt(Y(e)) : Y(e), month: $n.indexOf(n) + 1, day: Y(r), hour: Y(s), minute: Y(i) };
  return a && (o.second = Y(a)), t && (o.weekday = t.length > 3 ? In.indexOf(t) + 1 : xn.indexOf(t) + 1), o;
}
var ps = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function ws(t) {
  let [, e, n, r, s, i, a, o, l, u, d, y] = t, k = gt(e, s, r, n, i, a, o), m;
  return l ? m = gs[l] : u ? m = 0 : m = Pe(d, y), [k, new A(m)];
}
function vs(t) {
  return t.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
var ks = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, Ss = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, bs = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function Wt(t) {
  let [, e, n, r, s, i, a, o] = t;
  return [gt(e, s, r, n, i, a, o), A.utcInstance];
}
function Ts(t) {
  let [, e, n, r, s, i, a, o] = t;
  return [gt(e, o, n, r, s, i, a), A.utcInstance];
}
var Os = ae(is, yt), Ns = ae(as, yt), Ds = ae(os, yt), Ms = ae(An), qn = oe(hs, ue, Te, Oe), Es = oe(ls, ue, Te, Oe), $s = oe(us, ue, Te, Oe), Cs = oe(ue, Te, Oe);
function Is(t) {
  return le(t, [Os, qn], [Ns, Es], [Ds, $s], [Ms, Cs]);
}
function xs(t) {
  return le(vs(t), [ps, ws]);
}
function Vs(t) {
  return le(t, [ks, Wt], [Ss, Wt], [bs, Ts]);
}
function Fs(t) {
  return le(t, [fs, ys]);
}
var Ls = oe(ue);
function Ws(t) {
  return le(t, [ms, Ls]);
}
var Zs = ae(cs, ds), zs = ae(jn), As = oe(ue, Te, Oe);
function js(t) {
  return le(t, [Zs, qn], [zs, As]);
}
var Zt = "Invalid Duration", Un = { weeks: { days: 7, hours: 7 * 24, minutes: 7 * 24 * 60, seconds: 7 * 24 * 60 * 60, milliseconds: 7 * 24 * 60 * 60 * 1e3 }, days: { hours: 24, minutes: 24 * 60, seconds: 24 * 60 * 60, milliseconds: 24 * 60 * 60 * 1e3 }, hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 }, minutes: { seconds: 60, milliseconds: 60 * 1e3 }, seconds: { milliseconds: 1e3 } }, qs = f({ years: { quarters: 4, months: 12, weeks: 52, days: 365, hours: 365 * 24, minutes: 365 * 24 * 60, seconds: 365 * 24 * 60 * 60, milliseconds: 365 * 24 * 60 * 60 * 1e3 }, quarters: { months: 3, weeks: 13, days: 91, hours: 91 * 24, minutes: 91 * 24 * 60, seconds: 91 * 24 * 60 * 60, milliseconds: 91 * 24 * 60 * 60 * 1e3 }, months: { weeks: 4, days: 30, hours: 30 * 24, minutes: 30 * 24 * 60, seconds: 30 * 24 * 60 * 60, milliseconds: 30 * 24 * 60 * 60 * 1e3 } }, Un), C = 146097 / 400, Q = 146097 / 4800, Us = f({ years: { quarters: 4, months: 12, weeks: C / 7, days: C, hours: C * 24, minutes: C * 24 * 60, seconds: C * 24 * 60 * 60, milliseconds: C * 24 * 60 * 60 * 1e3 }, quarters: { months: 3, weeks: C / 28, days: C / 4, hours: C * 24 / 4, minutes: C * 24 * 60 / 4, seconds: C * 24 * 60 * 60 / 4, milliseconds: C * 24 * 60 * 60 * 1e3 / 4 }, months: { weeks: Q / 7, days: Q, hours: Q * 24, minutes: Q * 24 * 60, seconds: Q * 24 * 60 * 60, milliseconds: Q * 24 * 60 * 60 * 1e3 } }, Un), G = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"], Ys = G.slice(0).reverse();
function U(t, e, n = !1) {
  let r = { values: n ? e.values : f(f({}, t.values), e.values || {}), loc: t.loc.clone(e.loc), conversionAccuracy: e.conversionAccuracy || t.conversionAccuracy, matrix: e.matrix || t.matrix };
  return new E(r);
}
function Yn(t, e) {
  var n;
  let r = (n = e.milliseconds) != null ? n : 0;
  for (let s of Ys.slice(1)) e[s] && (r += e[s] * t[s].milliseconds);
  return r;
}
function zt(t, e) {
  let n = Yn(t, e) < 0 ? -1 : 1;
  G.reduceRight((r, s) => {
    if (h(e[s])) return r;
    if (r) {
      let i = e[r] * n, a = t[s][r], o = Math.floor(i / a);
      e[s] += o * n, e[r] -= o * a * n;
    }
    return s;
  }, null), G.reduce((r, s) => {
    if (h(e[s])) return r;
    if (r) {
      let i = e[r] % 1;
      e[r] -= i, e[s] += i * t[r][s];
    }
    return s;
  }, null);
}
function Hs(t) {
  let e = {};
  for (let [n, r] of Object.entries(t)) r !== 0 && (e[n] = r);
  return e;
}
var E = class N {
  constructor(e) {
    let n = e.conversionAccuracy === "longterm" || !1, r = n ? Us : qs;
    e.matrix && (r = e.matrix), this.values = e.values, this.loc = e.loc || p.create(), this.conversionAccuracy = n ? "longterm" : "casual", this.invalid = e.invalid || null, this.matrix = r, this.isLuxonDuration = !0;
  }
  static fromMillis(e, n) {
    return N.fromObject({ milliseconds: e }, n);
  }
  static fromObject(e, n = {}) {
    if (e == null || typeof e != "object") throw new M(`Duration.fromObject: argument expected to be an object, got ${e === null ? "null" : typeof e}`);
    return new N({ values: Ye(e, N.normalizeUnit), loc: p.fromObject(n), conversionAccuracy: n.conversionAccuracy, matrix: n.matrix });
  }
  static fromDurationLike(e) {
    if (R(e)) return N.fromMillis(e);
    if (N.isDuration(e)) return e;
    if (typeof e == "object") return N.fromObject(e);
    throw new M(`Unknown duration argument ${e} of type ${typeof e}`);
  }
  static fromISO(e, n) {
    let [r] = Fs(e);
    return r ? N.fromObject(r, n) : N.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  static fromISOTime(e, n) {
    let [r] = Ws(e);
    return r ? N.fromObject(r, n) : N.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  static invalid(e, n = null) {
    if (!e) throw new M("need to specify a reason the Duration is invalid");
    let r = e instanceof W ? e : new W(e, n);
    if (S.throwOnInvalid) throw new fr(r);
    return new N({ invalid: r });
  }
  static normalizeUnit(e) {
    let n = { year: "years", years: "years", quarter: "quarters", quarters: "quarters", month: "months", months: "months", week: "weeks", weeks: "weeks", day: "days", days: "days", hour: "hours", hours: "hours", minute: "minutes", minutes: "minutes", second: "seconds", seconds: "seconds", millisecond: "milliseconds", milliseconds: "milliseconds" }[e && e.toLowerCase()];
    if (!n) throw new _t(e);
    return n;
  }
  static isDuration(e) {
    return e && e.isLuxonDuration || !1;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  toFormat(e, n = {}) {
    let r = Z(f({}, n), { floor: n.round !== !1 && n.floor !== !1 });
    return this.isValid ? L.create(this.loc, r).formatDurationFromString(this, e) : Zt;
  }
  toHuman(e = {}) {
    if (!this.isValid) return Zt;
    let n = G.map((r) => {
      let s = this.values[r];
      return h(s) ? null : this.loc.numberFormatter(Z(f({ style: "unit", unitDisplay: "long" }, e), { unit: r.slice(0, -1) })).format(s);
    }).filter((r) => r);
    return this.loc.listFormatter(f({ type: "conjunction", style: e.listStyle || "narrow" }, e)).format(n);
  }
  toObject() {
    return this.isValid ? f({}, this.values) : {};
  }
  toISO() {
    if (!this.isValid) return null;
    let e = "P";
    return this.years !== 0 && (e += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (e += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (e += this.weeks + "W"), this.days !== 0 && (e += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (e += "T"), this.hours !== 0 && (e += this.hours + "H"), this.minutes !== 0 && (e += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (e += mt(this.seconds + this.milliseconds / 1e3, 3) + "S"), e === "P" && (e += "T0S"), e;
  }
  toISOTime(e = {}) {
    if (!this.isValid) return null;
    let n = this.toMillis();
    return n < 0 || n >= 864e5 ? null : (e = Z(f({ suppressMilliseconds: !1, suppressSeconds: !1, includePrefix: !1, format: "extended" }, e), { includeOffset: !1 }), b.fromMillis(n, { zone: "UTC" }).toISOTime(e));
  }
  toJSON() {
    return this.toISO();
  }
  toString() {
    return this.toISO();
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `Duration { values: ${JSON.stringify(this.values)} }` : `Duration { Invalid, reason: ${this.invalidReason} }`;
  }
  toMillis() {
    return this.isValid ? Yn(this.matrix, this.values) : NaN;
  }
  valueOf() {
    return this.toMillis();
  }
  plus(e) {
    if (!this.isValid) return this;
    let n = N.fromDurationLike(e), r = {};
    for (let s of G) (se(n.values, s) || se(this.values, s)) && (r[s] = n.get(s) + this.get(s));
    return U(this, { values: r }, !0);
  }
  minus(e) {
    if (!this.isValid) return this;
    let n = N.fromDurationLike(e);
    return this.plus(n.negate());
  }
  mapUnits(e) {
    if (!this.isValid) return this;
    let n = {};
    for (let r of Object.keys(this.values)) n[r] = En(e(this.values[r], r));
    return U(this, { values: n }, !0);
  }
  get(e) {
    return this[N.normalizeUnit(e)];
  }
  set(e) {
    if (!this.isValid) return this;
    let n = f(f({}, this.values), Ye(e, N.normalizeUnit));
    return U(this, { values: n });
  }
  reconfigure({ locale: e, numberingSystem: n, conversionAccuracy: r, matrix: s } = {}) {
    let i = { loc: this.loc.clone({ locale: e, numberingSystem: n }), matrix: s, conversionAccuracy: r };
    return U(this, i);
  }
  as(e) {
    return this.isValid ? this.shiftTo(e).get(e) : NaN;
  }
  normalize() {
    if (!this.isValid) return this;
    let e = this.toObject();
    return zt(this.matrix, e), U(this, { values: e }, !0);
  }
  rescale() {
    if (!this.isValid) return this;
    let e = Hs(this.normalize().shiftToAll().toObject());
    return U(this, { values: e }, !0);
  }
  shiftTo(...e) {
    if (!this.isValid) return this;
    if (e.length === 0) return this;
    e = e.map((a) => N.normalizeUnit(a));
    let n = {}, r = {}, s = this.toObject(), i;
    for (let a of G) if (e.indexOf(a) >= 0) {
      i = a;
      let o = 0;
      for (let u in r) o += this.matrix[u][a] * r[u], r[u] = 0;
      R(s[a]) && (o += s[a]);
      let l = Math.trunc(o);
      n[a] = l, r[a] = (o * 1e3 - l * 1e3) / 1e3;
    } else R(s[a]) && (r[a] = s[a]);
    for (let a in r) r[a] !== 0 && (n[i] += a === i ? r[a] : r[a] / this.matrix[i][a]);
    return zt(this.matrix, n), U(this, { values: n }, !0);
  }
  shiftToAll() {
    return this.isValid ? this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds") : this;
  }
  negate() {
    if (!this.isValid) return this;
    let e = {};
    for (let n of Object.keys(this.values)) e[n] = this.values[n] === 0 ? 0 : -this.values[n];
    return U(this, { values: e }, !0);
  }
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  equals(e) {
    if (!this.isValid || !e.isValid || !this.loc.equals(e.loc)) return !1;
    function n(r, s) {
      return r === void 0 || r === 0 ? s === void 0 || s === 0 : r === s;
    }
    for (let r of G) if (!n(this.values[r], e.values[r])) return !1;
    return !0;
  }
};
w();
var K = "Invalid Interval";
function Rs(t, e) {
  return !t || !t.isValid ? We.invalid("missing or invalid start") : !e || !e.isValid ? We.invalid("missing or invalid end") : e < t ? We.invalid("end before start", `The end of an interval must be after its start, but you had start=${t.toISO()} and end=${e.toISO()}`) : null;
}
var We = class O {
  constructor(e) {
    this.s = e.start, this.e = e.end, this.invalid = e.invalid || null, this.isLuxonInterval = !0;
  }
  static invalid(e, n = null) {
    if (!e) throw new M("need to specify a reason the Interval is invalid");
    let r = e instanceof W ? e : new W(e, n);
    if (S.throwOnInvalid) throw new mr(r);
    return new O({ invalid: r });
  }
  static fromDateTimes(e, n) {
    let r = fe(e), s = fe(n), i = Rs(r, s);
    return i ?? new O({ start: r, end: s });
  }
  static after(e, n) {
    let r = E.fromDurationLike(n), s = fe(e);
    return O.fromDateTimes(s, s.plus(r));
  }
  static before(e, n) {
    let r = E.fromDurationLike(n), s = fe(e);
    return O.fromDateTimes(s.minus(r), s);
  }
  static fromISO(e, n) {
    let [r, s] = (e || "").split("/", 2);
    if (r && s) {
      let i, a;
      try {
        i = b.fromISO(r, n), a = i.isValid;
      } catch {
        a = !1;
      }
      let o, l;
      try {
        o = b.fromISO(s, n), l = o.isValid;
      } catch {
        l = !1;
      }
      if (a && l) return O.fromDateTimes(i, o);
      if (a) {
        let u = E.fromISO(s, n);
        if (u.isValid) return O.after(i, u);
      } else if (l) {
        let u = E.fromISO(r, n);
        if (u.isValid) return O.before(o, u);
      }
    }
    return O.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  static isInterval(e) {
    return e && e.isLuxonInterval || !1;
  }
  get start() {
    return this.isValid ? this.s : null;
  }
  get end() {
    return this.isValid ? this.e : null;
  }
  get isValid() {
    return this.invalidReason === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  length(e = "milliseconds") {
    return this.isValid ? this.toDuration(e).get(e) : NaN;
  }
  count(e = "milliseconds", n) {
    if (!this.isValid) return NaN;
    let r = this.start.startOf(e, n), s;
    return n != null && n.useLocaleWeeks ? s = this.end.reconfigure({ locale: r.locale }) : s = this.end, s = s.startOf(e, n), Math.floor(s.diff(r, e).get(e)) + (s.valueOf() !== this.end.valueOf());
  }
  hasSame(e) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, e) : !1;
  }
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  isAfter(e) {
    return this.isValid ? this.s > e : !1;
  }
  isBefore(e) {
    return this.isValid ? this.e <= e : !1;
  }
  contains(e) {
    return this.isValid ? this.s <= e && this.e > e : !1;
  }
  set({ start: e, end: n } = {}) {
    return this.isValid ? O.fromDateTimes(e || this.s, n || this.e) : this;
  }
  splitAt(...e) {
    if (!this.isValid) return [];
    let n = e.map(fe).filter((a) => this.contains(a)).sort((a, o) => a.toMillis() - o.toMillis()), r = [], { s } = this, i = 0;
    for (; s < this.e; ) {
      let a = n[i] || this.e, o = +a > +this.e ? this.e : a;
      r.push(O.fromDateTimes(s, o)), s = o, i += 1;
    }
    return r;
  }
  splitBy(e) {
    let n = E.fromDurationLike(e);
    if (!this.isValid || !n.isValid || n.as("milliseconds") === 0) return [];
    let { s: r } = this, s = 1, i, a = [];
    for (; r < this.e; ) {
      let o = this.start.plus(n.mapUnits((l) => l * s));
      i = +o > +this.e ? this.e : o, a.push(O.fromDateTimes(r, i)), r = i, s += 1;
    }
    return a;
  }
  divideEqually(e) {
    return this.isValid ? this.splitBy(this.length() / e).slice(0, e) : [];
  }
  overlaps(e) {
    return this.e > e.s && this.s < e.e;
  }
  abutsStart(e) {
    return this.isValid ? +this.e == +e.s : !1;
  }
  abutsEnd(e) {
    return this.isValid ? +e.e == +this.s : !1;
  }
  engulfs(e) {
    return this.isValid ? this.s <= e.s && this.e >= e.e : !1;
  }
  equals(e) {
    return !this.isValid || !e.isValid ? !1 : this.s.equals(e.s) && this.e.equals(e.e);
  }
  intersection(e) {
    if (!this.isValid) return this;
    let n = this.s > e.s ? this.s : e.s, r = this.e < e.e ? this.e : e.e;
    return n >= r ? null : O.fromDateTimes(n, r);
  }
  union(e) {
    if (!this.isValid) return this;
    let n = this.s < e.s ? this.s : e.s, r = this.e > e.e ? this.e : e.e;
    return O.fromDateTimes(n, r);
  }
  static merge(e) {
    let [n, r] = e.sort((s, i) => s.s - i.s).reduce(([s, i], a) => i ? i.overlaps(a) || i.abutsStart(a) ? [s, i.union(a)] : [s.concat([i]), a] : [s, a], [[], null]);
    return r && n.push(r), n;
  }
  static xor(e) {
    let n = null, r = 0, s = [], i = e.map((l) => [{ time: l.s, type: "s" }, { time: l.e, type: "e" }]), a = Array.prototype.concat(...i), o = a.sort((l, u) => l.time - u.time);
    for (let l of o) r += l.type === "s" ? 1 : -1, r === 1 ? n = l.time : (n && +n != +l.time && s.push(O.fromDateTimes(n, l.time)), n = null);
    return O.merge(s);
  }
  difference(...e) {
    return O.xor([this].concat(e)).map((n) => this.intersection(n)).filter((n) => n && !n.isEmpty());
  }
  toString() {
    return this.isValid ? `[${this.s.toISO()} – ${this.e.toISO()})` : K;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }` : `Interval { Invalid, reason: ${this.invalidReason} }`;
  }
  toLocaleString(e = je, n = {}) {
    return this.isValid ? L.create(this.s.loc.clone(n), e).formatInterval(this) : K;
  }
  toISO(e) {
    return this.isValid ? `${this.s.toISO(e)}/${this.e.toISO(e)}` : K;
  }
  toISODate() {
    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : K;
  }
  toISOTime(e) {
    return this.isValid ? `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}` : K;
  }
  toFormat(e, { separator: n = " – " } = {}) {
    return this.isValid ? `${this.s.toFormat(e)}${n}${this.e.toFormat(e)}` : K;
  }
  toDuration(e, n) {
    return this.isValid ? this.e.diff(this.s, e, n) : E.invalid(this.invalidReason);
  }
  mapEndpoints(e) {
    return O.fromDateTimes(e(this.s), e(this.e));
  }
};
w();
var $e = class {
  static hasDST(t = S.defaultZone) {
    let e = b.now().setZone(t).set({ month: 12 });
    return !t.isUniversal && e.offset !== e.set({ month: 6 }).offset;
  }
  static isValidIANAZone(t) {
    return ie.isValidZone(t);
  }
  static normalizeZone(t) {
    return H(t, S.defaultZone);
  }
  static getStartOfWeek({ locale: t = null, locObj: e = null } = {}) {
    return (e || p.create(t)).getStartOfWeek();
  }
  static getMinimumDaysInFirstWeek({ locale: t = null, locObj: e = null } = {}) {
    return (e || p.create(t)).getMinDaysInFirstWeek();
  }
  static getWeekendWeekdays({ locale: t = null, locObj: e = null } = {}) {
    return (e || p.create(t)).getWeekendDays().slice();
  }
  static months(t = "long", { locale: e = null, numberingSystem: n = null, locObj: r = null, outputCalendar: s = "gregory" } = {}) {
    return (r || p.create(e, n, s)).months(t);
  }
  static monthsFormat(t = "long", { locale: e = null, numberingSystem: n = null, locObj: r = null, outputCalendar: s = "gregory" } = {}) {
    return (r || p.create(e, n, s)).months(t, !0);
  }
  static weekdays(t = "long", { locale: e = null, numberingSystem: n = null, locObj: r = null } = {}) {
    return (r || p.create(e, n, null)).weekdays(t);
  }
  static weekdaysFormat(t = "long", { locale: e = null, numberingSystem: n = null, locObj: r = null } = {}) {
    return (r || p.create(e, n, null)).weekdays(t, !0);
  }
  static meridiems({ locale: t = null } = {}) {
    return p.create(t).meridiems();
  }
  static eras(t = "short", { locale: e = null } = {}) {
    return p.create(e, null, "gregory").eras(t);
  }
  static features() {
    return { relative: Nn(), localeWeek: Dn() };
  }
};
w();
function At(t, e) {
  let n = (s) => s.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), r = n(e) - n(t);
  return Math.floor(E.fromMillis(r).as("days"));
}
function Ps(t, e, n) {
  let r = [["years", (l, u) => u.year - l.year], ["quarters", (l, u) => u.quarter - l.quarter + (u.year - l.year) * 4], ["months", (l, u) => u.month - l.month + (u.year - l.year) * 12], ["weeks", (l, u) => {
    let d = At(l, u);
    return (d - d % 7) / 7;
  }], ["days", At]], s = {}, i = t, a, o;
  for (let [l, u] of r) n.indexOf(l) >= 0 && (a = l, s[l] = u(t, e), o = i.plus(s), o > e ? (s[l]--, t = i.plus(s), t > e && (o = t, s[l]--, t = i.plus(s))) : t = o);
  return [t, s, o, a];
}
function Js(t, e, n, r) {
  let [s, i, a, o] = Ps(t, e, n), l = e - s, u = n.filter((y) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(y) >= 0);
  u.length === 0 && (a < e && (a = s.plus({ [o]: 1 })), a !== s && (i[o] = (i[o] || 0) + l / (a - s)));
  let d = E.fromObject(i, r);
  return u.length > 0 ? E.fromMillis(l, r).shiftTo(...u).plus(d) : d;
}
w();
var Gs = "missing Intl.DateTimeFormat.formatToParts support";
function g(t, e = (n) => n) {
  return { regex: t, deser: ([n]) => e(Zr(n)) };
}
var Bs = " ", Hn = `[ ${Bs}]`, Rn = new RegExp(Hn, "g");
function _s(t) {
  return t.replace(/\./g, "\\.?").replace(Rn, Hn);
}
function jt(t) {
  return t.replace(/\./g, "").replace(Rn, " ").toLowerCase();
}
function F(t, e) {
  return t === null ? null : { regex: RegExp(t.map(_s).join("|")), deser: ([n]) => t.findIndex((r) => jt(n) === jt(r)) + e };
}
function qt(t, e) {
  return { regex: t, deser: ([, n, r]) => Pe(n, r), groups: e };
}
function Ce(t) {
  return { regex: t, deser: ([e]) => e };
}
function Qs(t) {
  return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function Ks(t, e) {
  let n = V(e), r = V(e, "{2}"), s = V(e, "{3}"), i = V(e, "{4}"), a = V(e, "{6}"), o = V(e, "{1,2}"), l = V(e, "{1,3}"), u = V(e, "{1,6}"), d = V(e, "{1,9}"), y = V(e, "{2,4}"), k = V(e, "{4,6}"), m = (j) => ({ regex: RegExp(Qs(j.val)), deser: ([_]) => _, literal: !0 }), D = ((j) => {
    if (t.literal) return m(j);
    switch (j.val) {
      case "G":
        return F(e.eras("short"), 0);
      case "GG":
        return F(e.eras("long"), 0);
      case "y":
        return g(u);
      case "yy":
        return g(y, lt);
      case "yyyy":
        return g(i);
      case "yyyyy":
        return g(k);
      case "yyyyyy":
        return g(a);
      case "M":
        return g(o);
      case "MM":
        return g(r);
      case "MMM":
        return F(e.months("short", !0), 1);
      case "MMMM":
        return F(e.months("long", !0), 1);
      case "L":
        return g(o);
      case "LL":
        return g(r);
      case "LLL":
        return F(e.months("short", !1), 1);
      case "LLLL":
        return F(e.months("long", !1), 1);
      case "d":
        return g(o);
      case "dd":
        return g(r);
      case "o":
        return g(l);
      case "ooo":
        return g(s);
      case "HH":
        return g(r);
      case "H":
        return g(o);
      case "hh":
        return g(r);
      case "h":
        return g(o);
      case "mm":
        return g(r);
      case "m":
        return g(o);
      case "q":
        return g(o);
      case "qq":
        return g(r);
      case "s":
        return g(o);
      case "ss":
        return g(r);
      case "S":
        return g(l);
      case "SSS":
        return g(s);
      case "u":
        return Ce(d);
      case "uu":
        return Ce(o);
      case "uuu":
        return g(n);
      case "a":
        return F(e.meridiems(), 0);
      case "kkkk":
        return g(i);
      case "kk":
        return g(y, lt);
      case "W":
        return g(o);
      case "WW":
        return g(r);
      case "E":
      case "c":
        return g(n);
      case "EEE":
        return F(e.weekdays("short", !1), 1);
      case "EEEE":
        return F(e.weekdays("long", !1), 1);
      case "ccc":
        return F(e.weekdays("short", !0), 1);
      case "cccc":
        return F(e.weekdays("long", !0), 1);
      case "Z":
      case "ZZ":
        return qt(new RegExp(`([+-]${o.source})(?::(${r.source}))?`), 2);
      case "ZZZ":
        return qt(new RegExp(`([+-]${o.source})(${r.source})?`), 2);
      case "z":
        return Ce(/[a-z_+-/]{1,256}?/i);
      case " ":
        return Ce(/[^\S\n\r]/);
      default:
        return m(j);
    }
  })(t) || { invalidReason: Gs };
  return D.token = t, D;
}
var Xs = { year: { "2-digit": "yy", numeric: "yyyyy" }, month: { numeric: "M", "2-digit": "MM", short: "MMM", long: "MMMM" }, day: { numeric: "d", "2-digit": "dd" }, weekday: { short: "EEE", long: "EEEE" }, dayperiod: "a", dayPeriod: "a", hour12: { numeric: "h", "2-digit": "hh" }, hour24: { numeric: "H", "2-digit": "HH" }, minute: { numeric: "m", "2-digit": "mm" }, second: { numeric: "s", "2-digit": "ss" }, timeZoneName: { long: "ZZZZZ", short: "ZZZ" } };
function ei(t, e, n) {
  let { type: r, value: s } = t;
  if (r === "literal") {
    let l = /^\s+$/.test(s);
    return { literal: !l, val: l ? " " : s };
  }
  let i = e[r], a = r;
  r === "hour" && (e.hour12 != null ? a = e.hour12 ? "hour12" : "hour24" : e.hourCycle != null ? e.hourCycle === "h11" || e.hourCycle === "h12" ? a = "hour12" : a = "hour24" : a = n.hour12 ? "hour12" : "hour24");
  let o = Xs[a];
  if (typeof o == "object" && (o = o[i]), o) return { literal: !1, val: o };
}
function ti(t) {
  return [`^${t.map((e) => e.regex).reduce((e, n) => `${e}(${n.source})`, "")}$`, t];
}
function ni(t, e, n) {
  let r = t.match(e);
  if (r) {
    let s = {}, i = 1;
    for (let a in n) if (se(n, a)) {
      let o = n[a], l = o.groups ? o.groups + 1 : 1;
      !o.literal && o.token && (s[o.token.val[0]] = o.deser(r.slice(i, i + l))), i += l;
    }
    return [r, s];
  } else return [r, {}];
}
function ri(t) {
  let e = (s) => {
    switch (s) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  }, n = null, r;
  return h(t.z) || (n = ie.create(t.z)), h(t.Z) || (n || (n = new A(t.Z)), r = t.Z), h(t.q) || (t.M = (t.q - 1) * 3 + 1), h(t.h) || (t.h < 12 && t.a === 1 ? t.h += 12 : t.h === 12 && t.a === 0 && (t.h = 0)), t.G === 0 && t.y && (t.y = -t.y), h(t.u) || (t.S = ht(t.u)), [Object.keys(t).reduce((s, i) => {
    let a = e(i);
    return a && (s[a] = t[i]), s;
  }, {}), n, r];
}
var Qe = null;
function si() {
  return Qe || (Qe = b.fromMillis(1555555555555)), Qe;
}
function ii(t, e) {
  if (t.literal) return t;
  let n = L.macroTokenToFormatOpts(t.val), r = Bn(n, e);
  return r == null || r.includes(void 0) ? t : r;
}
function Pn(t, e) {
  return Array.prototype.concat(...t.map((n) => ii(n, e)));
}
var Jn = class {
  constructor(t, e) {
    if (this.locale = t, this.format = e, this.tokens = Pn(L.parseFormat(e), t), this.units = this.tokens.map((n) => Ks(n, t)), this.disqualifyingUnit = this.units.find((n) => n.invalidReason), !this.disqualifyingUnit) {
      let [n, r] = ti(this.units);
      this.regex = RegExp(n, "i"), this.handlers = r;
    }
  }
  explainFromTokens(t) {
    if (this.isValid) {
      let [e, n] = ni(t, this.regex, this.handlers), [r, s, i] = n ? ri(n) : [null, null, void 0];
      if (se(n, "a") && se(n, "H")) throw new te("Can't include meridiem when specifying 24-hour format");
      return { input: t, tokens: this.tokens, regex: this.regex, rawMatches: e, matches: n, result: r, zone: s, specificOffset: i };
    } else return { input: t, tokens: this.tokens, invalidReason: this.invalidReason };
  }
  get isValid() {
    return !this.disqualifyingUnit;
  }
  get invalidReason() {
    return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;
  }
};
function Gn(t, e, n) {
  return new Jn(t, n).explainFromTokens(e);
}
function ai(t, e, n) {
  let { result: r, zone: s, specificOffset: i, invalidReason: a } = Gn(t, e, n);
  return [r, s, i, a];
}
function Bn(t, e) {
  if (!t) return null;
  let n = L.create(e, t).dtFormatter(si()), r = n.formatToParts(), s = n.resolvedOptions();
  return r.map((i) => ei(i, t, s));
}
var Ke = "Invalid DateTime", Ut = 864e13;
function we(t) {
  return new W("unsupported zone", `the zone "${t.name}" is not supported`);
}
function Xe(t) {
  return t.weekData === null && (t.weekData = qe(t.c)), t.weekData;
}
function et(t) {
  return t.localWeekData === null && (t.localWeekData = qe(t.c, t.loc.getMinDaysInFirstWeek(), t.loc.getStartOfWeek())), t.localWeekData;
}
function J(t, e) {
  let n = { ts: t.ts, zone: t.zone, c: t.c, o: t.o, loc: t.loc, invalid: t.invalid };
  return new b(Z(f(f({}, n), e), { old: n }));
}
function _n(t, e, n) {
  let r = t - e * 60 * 1e3, s = n.offset(r);
  if (e === s) return [r, e];
  r -= (s - e) * 60 * 1e3;
  let i = n.offset(r);
  return s === i ? [r, s] : [t - Math.min(s, i) * 60 * 1e3, Math.max(s, i)];
}
function Ie(t, e) {
  t += e * 60 * 1e3;
  let n = new Date(t);
  return { year: n.getUTCFullYear(), month: n.getUTCMonth() + 1, day: n.getUTCDate(), hour: n.getUTCHours(), minute: n.getUTCMinutes(), second: n.getUTCSeconds(), millisecond: n.getUTCMilliseconds() };
}
function Ze(t, e, n) {
  return _n(Re(t), e, n);
}
function Yt(t, e) {
  let n = t.o, r = t.c.year + Math.trunc(e.years), s = t.c.month + Math.trunc(e.months) + Math.trunc(e.quarters) * 3, i = Z(f({}, t.c), { year: r, month: s, day: Math.min(t.c.day, Ue(r, s)) + Math.trunc(e.days) + Math.trunc(e.weeks) * 7 }), a = E.fromObject({ years: e.years - Math.trunc(e.years), quarters: e.quarters - Math.trunc(e.quarters), months: e.months - Math.trunc(e.months), weeks: e.weeks - Math.trunc(e.weeks), days: e.days - Math.trunc(e.days), hours: e.hours, minutes: e.minutes, seconds: e.seconds, milliseconds: e.milliseconds }).as("milliseconds"), o = Re(i), [l, u] = _n(o, n, t.zone);
  return a !== 0 && (l += a, u = t.zone.offset(l)), { ts: l, o: u };
}
function X(t, e, n, r, s, i) {
  let { setZone: a, zone: o } = n;
  if (t && Object.keys(t).length !== 0 || e) {
    let l = e || o, u = b.fromObject(t, Z(f({}, n), { zone: l, specificOffset: i }));
    return a ? u : u.setZone(o);
  } else return b.invalid(new W("unparsable", `the input "${s}" can't be parsed as ${r}`));
}
function xe(t, e, n = !0) {
  return t.isValid ? L.create(p.create("en-US"), { allowZ: n, forceSimple: !0 }).formatDateTimeFromString(t, e) : null;
}
function tt(t, e) {
  let n = t.c.year > 9999 || t.c.year < 0, r = "";
  return n && t.c.year >= 0 && (r += "+"), r += T(t.c.year, n ? 6 : 4), e ? (r += "-", r += T(t.c.month), r += "-", r += T(t.c.day)) : (r += T(t.c.month), r += T(t.c.day)), r;
}
function Ht(t, e, n, r, s, i) {
  let a = T(t.c.hour);
  return e ? (a += ":", a += T(t.c.minute), (t.c.millisecond !== 0 || t.c.second !== 0 || !n) && (a += ":")) : a += T(t.c.minute), (t.c.millisecond !== 0 || t.c.second !== 0 || !n) && (a += T(t.c.second), (t.c.millisecond !== 0 || !r) && (a += ".", a += T(t.c.millisecond, 3))), s && (t.isOffsetFixed && t.offset === 0 && !i ? a += "Z" : t.o < 0 ? (a += "-", a += T(Math.trunc(-t.o / 60)), a += ":", a += T(Math.trunc(-t.o % 60))) : (a += "+", a += T(Math.trunc(t.o / 60)), a += ":", a += T(Math.trunc(t.o % 60)))), i && (a += "[" + t.zone.ianaName + "]"), a;
}
var Qn = { month: 1, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0 }, oi = { weekNumber: 1, weekday: 1, hour: 0, minute: 0, second: 0, millisecond: 0 }, li = { ordinal: 1, hour: 0, minute: 0, second: 0, millisecond: 0 }, Kn = ["year", "month", "day", "hour", "minute", "second", "millisecond"], ui = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"], ci = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function di(t) {
  let e = { year: "year", years: "year", month: "month", months: "month", day: "day", days: "day", hour: "hour", hours: "hour", minute: "minute", minutes: "minute", quarter: "quarter", quarters: "quarter", second: "second", seconds: "second", millisecond: "millisecond", milliseconds: "millisecond", weekday: "weekday", weekdays: "weekday", weeknumber: "weekNumber", weeksnumber: "weekNumber", weeknumbers: "weekNumber", weekyear: "weekYear", weekyears: "weekYear", ordinal: "ordinal" }[t.toLowerCase()];
  if (!e) throw new _t(t);
  return e;
}
function Rt(t) {
  switch (t.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return di(t);
  }
}
function hi(t) {
  return Ae[t] || (ze === void 0 && (ze = S.now()), Ae[t] = t.offset(ze)), Ae[t];
}
function Pt(t, e) {
  let n = H(e.zone, S.defaultZone);
  if (!n.isValid) return b.invalid(we(n));
  let r = p.fromObject(e), s, i;
  if (h(t.year)) s = S.now();
  else {
    for (let l of Kn) h(t[l]) && (t[l] = Qn[l]);
    let a = Tn(t) || On(t);
    if (a) return b.invalid(a);
    let o = hi(n);
    [s, i] = Ze(t, o, n);
  }
  return new b({ ts: s, zone: n, loc: r, o: i });
}
function Jt(t, e, n) {
  let r = h(n.round) ? !0 : n.round, s = (a, o) => (a = mt(a, r || n.calendary ? 0 : 2, !0), e.loc.clone(n).relFormatter(n).format(a, o)), i = (a) => n.calendary ? e.hasSame(t, a) ? 0 : e.startOf(a).diff(t.startOf(a), a).get(a) : e.diff(t, a).get(a);
  if (n.unit) return s(i(n.unit), n.unit);
  for (let a of n.units) {
    let o = i(a);
    if (Math.abs(o) >= 1) return s(o, a);
  }
  return s(t > e ? -0 : 0, n.units[n.units.length - 1]);
}
function Gt(t) {
  let e = {}, n;
  return t.length > 0 && typeof t[t.length - 1] == "object" ? (e = t[t.length - 1], n = Array.from(t).slice(0, t.length - 1)) : n = Array.from(t), [e, n];
}
var ze, Ae = {}, b = class v {
  constructor(e) {
    let n = e.zone || S.defaultZone, r = e.invalid || (Number.isNaN(e.ts) ? new W("invalid input") : null) || (n.isValid ? null : we(n));
    this.ts = h(e.ts) ? S.now() : e.ts;
    let s = null, i = null;
    if (!r) if (e.old && e.old.ts === this.ts && e.old.zone.equals(n)) [s, i] = [e.old.c, e.old.o];
    else {
      let a = R(e.o) && !e.old ? e.o : n.offset(this.ts);
      s = Ie(this.ts, a), r = Number.isNaN(s.year) ? new W("invalid input") : null, s = r ? null : s, i = r ? null : a;
    }
    this._zone = n, this.loc = e.loc || p.create(), this.invalid = r, this.weekData = null, this.localWeekData = null, this.c = s, this.o = i, this.isLuxonDateTime = !0;
  }
  static now() {
    return new v({});
  }
  static local() {
    let [e, n] = Gt(arguments), [r, s, i, a, o, l, u] = n;
    return Pt({ year: r, month: s, day: i, hour: a, minute: o, second: l, millisecond: u }, e);
  }
  static utc() {
    let [e, n] = Gt(arguments), [r, s, i, a, o, l, u] = n;
    return e.zone = A.utcInstance, Pt({ year: r, month: s, day: i, hour: a, minute: o, second: l, millisecond: u }, e);
  }
  static fromJSDate(e, n = {}) {
    let r = Ur(e) ? e.valueOf() : NaN;
    if (Number.isNaN(r)) return v.invalid("invalid input");
    let s = H(n.zone, S.defaultZone);
    return s.isValid ? new v({ ts: r, zone: s, loc: p.fromObject(n) }) : v.invalid(we(s));
  }
  static fromMillis(e, n = {}) {
    if (R(e)) return e < -Ut || e > Ut ? v.invalid("Timestamp out of range") : new v({ ts: e, zone: H(n.zone, S.defaultZone), loc: p.fromObject(n) });
    throw new M(`fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`);
  }
  static fromSeconds(e, n = {}) {
    if (R(e)) return new v({ ts: e * 1e3, zone: H(n.zone, S.defaultZone), loc: p.fromObject(n) });
    throw new M("fromSeconds requires a numerical input");
  }
  static fromObject(e, n = {}) {
    e = e || {};
    let r = H(n.zone, S.defaultZone);
    if (!r.isValid) return v.invalid(we(r));
    let s = p.fromObject(n), i = Ye(e, Rt), { minDaysInFirstWeek: a, startOfWeek: o } = xt(i, s), l = S.now(), u = h(n.specificOffset) ? r.offset(l) : n.specificOffset, d = !h(i.ordinal), y = !h(i.year), k = !h(i.month) || !h(i.day), m = y || k, D = i.weekYear || i.weekNumber;
    if ((m || d) && D) throw new te("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    if (k && d) throw new te("Can't mix ordinal dates with month/day");
    let j = D || i.weekday && !m, _, Ne, ce = Ie(l, u);
    j ? (_ = ui, Ne = oi, ce = qe(ce, a, o)) : d ? (_ = ci, Ne = li, ce = _e(ce)) : (_ = Kn, Ne = Qn);
    let pt = !1;
    for (let he of _) {
      let sr = i[he];
      h(sr) ? pt ? i[he] = Ne[he] : i[he] = ce[he] : pt = !0;
    }
    let er = j ? Ar(i, a, o) : d ? jr(i) : Tn(i), wt = er || On(i);
    if (wt) return v.invalid(wt);
    let tr = j ? Ct(i, a, o) : d ? It(i) : i, [nr, rr] = Ze(tr, u, r), de = new v({ ts: nr, zone: r, o: rr, loc: s });
    return i.weekday && m && e.weekday !== de.weekday ? v.invalid("mismatched weekday", `you can't specify both a weekday of ${i.weekday} and a date of ${de.toISO()}`) : de.isValid ? de : v.invalid(de.invalid);
  }
  static fromISO(e, n = {}) {
    let [r, s] = Is(e);
    return X(r, s, n, "ISO 8601", e);
  }
  static fromRFC2822(e, n = {}) {
    let [r, s] = xs(e);
    return X(r, s, n, "RFC 2822", e);
  }
  static fromHTTP(e, n = {}) {
    let [r, s] = Vs(e);
    return X(r, s, n, "HTTP", n);
  }
  static fromFormat(e, n, r = {}) {
    if (h(e) || h(n)) throw new M("fromFormat requires an input string and a format");
    let { locale: s = null, numberingSystem: i = null } = r, a = p.fromOpts({ locale: s, numberingSystem: i, defaultToEN: !0 }), [o, l, u, d] = ai(a, e, n);
    return d ? v.invalid(d) : X(o, l, r, `format ${n}`, e, u);
  }
  static fromString(e, n, r = {}) {
    return v.fromFormat(e, n, r);
  }
  static fromSQL(e, n = {}) {
    let [r, s] = js(e);
    return X(r, s, n, "SQL", e);
  }
  static invalid(e, n = null) {
    if (!e) throw new M("need to specify a reason the DateTime is invalid");
    let r = e instanceof W ? e : new W(e, n);
    if (S.throwOnInvalid) throw new hr(r);
    return new v({ invalid: r });
  }
  static isDateTime(e) {
    return e && e.isLuxonDateTime || !1;
  }
  static parseFormatForOpts(e, n = {}) {
    let r = Bn(e, p.fromObject(n));
    return r ? r.map((s) => s ? s.val : null).join("") : null;
  }
  static expandFormat(e, n = {}) {
    return Pn(L.parseFormat(e), p.fromObject(n)).map((r) => r.val).join("");
  }
  static resetCache() {
    ze = void 0, Ae = {};
  }
  get(e) {
    return this[e];
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  get zone() {
    return this._zone;
  }
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  get weekYear() {
    return this.isValid ? Xe(this).weekYear : NaN;
  }
  get weekNumber() {
    return this.isValid ? Xe(this).weekNumber : NaN;
  }
  get weekday() {
    return this.isValid ? Xe(this).weekday : NaN;
  }
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  get localWeekday() {
    return this.isValid ? et(this).weekday : NaN;
  }
  get localWeekNumber() {
    return this.isValid ? et(this).weekNumber : NaN;
  }
  get localWeekYear() {
    return this.isValid ? et(this).weekYear : NaN;
  }
  get ordinal() {
    return this.isValid ? _e(this.c).ordinal : NaN;
  }
  get monthShort() {
    return this.isValid ? $e.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  get monthLong() {
    return this.isValid ? $e.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  get weekdayShort() {
    return this.isValid ? $e.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get weekdayLong() {
    return this.isValid ? $e.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  get offsetNameShort() {
    return this.isValid ? this.zone.offsetName(this.ts, { format: "short", locale: this.locale }) : null;
  }
  get offsetNameLong() {
    return this.isValid ? this.zone.offsetName(this.ts, { format: "long", locale: this.locale }) : null;
  }
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  get isInDST() {
    return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
  }
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed) return [this];
    let e = 864e5, n = 6e4, r = Re(this.c), s = this.zone.offset(r - e), i = this.zone.offset(r + e), a = this.zone.offset(r - s * n), o = this.zone.offset(r - i * n);
    if (a === o) return [this];
    let l = r - a * n, u = r - o * n, d = Ie(l, a), y = Ie(u, o);
    return d.hour === y.hour && d.minute === y.minute && d.second === y.second && d.millisecond === y.millisecond ? [J(this, { ts: l }), J(this, { ts: u })] : [this];
  }
  get isInLeapYear() {
    return be(this.year);
  }
  get daysInMonth() {
    return Ue(this.year, this.month);
  }
  get daysInYear() {
    return this.isValid ? ne(this.year) : NaN;
  }
  get weeksInWeekYear() {
    return this.isValid ? ke(this.weekYear) : NaN;
  }
  get weeksInLocalWeekYear() {
    return this.isValid ? ke(this.localWeekYear, this.loc.getMinDaysInFirstWeek(), this.loc.getStartOfWeek()) : NaN;
  }
  resolvedLocaleOptions(e = {}) {
    let { locale: n, numberingSystem: r, calendar: s } = L.create(this.loc.clone(e), e).resolvedOptions(this);
    return { locale: n, numberingSystem: r, outputCalendar: s };
  }
  toUTC(e = 0, n = {}) {
    return this.setZone(A.instance(e), n);
  }
  toLocal() {
    return this.setZone(S.defaultZone);
  }
  setZone(e, { keepLocalTime: n = !1, keepCalendarTime: r = !1 } = {}) {
    if (e = H(e, S.defaultZone), e.equals(this.zone)) return this;
    if (e.isValid) {
      let s = this.ts;
      if (n || r) {
        let i = e.offset(this.ts), a = this.toObject();
        [s] = Ze(a, i, e);
      }
      return J(this, { ts: s, zone: e });
    } else return v.invalid(we(e));
  }
  reconfigure({ locale: e, numberingSystem: n, outputCalendar: r } = {}) {
    let s = this.loc.clone({ locale: e, numberingSystem: n, outputCalendar: r });
    return J(this, { loc: s });
  }
  setLocale(e) {
    return this.reconfigure({ locale: e });
  }
  set(e) {
    if (!this.isValid) return this;
    let n = Ye(e, Rt), { minDaysInFirstWeek: r, startOfWeek: s } = xt(n, this.loc), i = !h(n.weekYear) || !h(n.weekNumber) || !h(n.weekday), a = !h(n.ordinal), o = !h(n.year), l = !h(n.month) || !h(n.day), u = o || l, d = n.weekYear || n.weekNumber;
    if ((u || a) && d) throw new te("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    if (l && a) throw new te("Can't mix ordinal dates with month/day");
    let y;
    i ? y = Ct(f(f({}, qe(this.c, r, s)), n), r, s) : h(n.ordinal) ? (y = f(f({}, this.toObject()), n), h(n.day) && (y.day = Math.min(Ue(y.year, y.month), y.day))) : y = It(f(f({}, _e(this.c)), n));
    let [k, m] = Ze(y, this.o, this.zone);
    return J(this, { ts: k, o: m });
  }
  plus(e) {
    if (!this.isValid) return this;
    let n = E.fromDurationLike(e);
    return J(this, Yt(this, n));
  }
  minus(e) {
    if (!this.isValid) return this;
    let n = E.fromDurationLike(e).negate();
    return J(this, Yt(this, n));
  }
  startOf(e, { useLocaleWeeks: n = !1 } = {}) {
    if (!this.isValid) return this;
    let r = {}, s = E.normalizeUnit(e);
    switch (s) {
      case "years":
        r.month = 1;
      case "quarters":
      case "months":
        r.day = 1;
      case "weeks":
      case "days":
        r.hour = 0;
      case "hours":
        r.minute = 0;
      case "minutes":
        r.second = 0;
      case "seconds":
        r.millisecond = 0;
        break;
    }
    if (s === "weeks") if (n) {
      let i = this.loc.getStartOfWeek(), { weekday: a } = this;
      a < i && (r.weekNumber = this.weekNumber - 1), r.weekday = i;
    } else r.weekday = 1;
    if (s === "quarters") {
      let i = Math.ceil(this.month / 3);
      r.month = (i - 1) * 3 + 1;
    }
    return this.set(r);
  }
  endOf(e, n) {
    return this.isValid ? this.plus({ [e]: 1 }).startOf(e, n).minus(1) : this;
  }
  toFormat(e, n = {}) {
    return this.isValid ? L.create(this.loc.redefaultToEN(n)).formatDateTimeFromString(this, e) : Ke;
  }
  toLocaleString(e = je, n = {}) {
    return this.isValid ? L.create(this.loc.clone(n), e).formatDateTime(this) : Ke;
  }
  toLocaleParts(e = {}) {
    return this.isValid ? L.create(this.loc.clone(e), e).formatDateTimeParts(this) : [];
  }
  toISO({ format: e = "extended", suppressSeconds: n = !1, suppressMilliseconds: r = !1, includeOffset: s = !0, extendedZone: i = !1 } = {}) {
    if (!this.isValid) return null;
    let a = e === "extended", o = tt(this, a);
    return o += "T", o += Ht(this, a, n, r, s, i), o;
  }
  toISODate({ format: e = "extended" } = {}) {
    return this.isValid ? tt(this, e === "extended") : null;
  }
  toISOWeekDate() {
    return xe(this, "kkkk-'W'WW-c");
  }
  toISOTime({ suppressMilliseconds: e = !1, suppressSeconds: n = !1, includeOffset: r = !0, includePrefix: s = !1, extendedZone: i = !1, format: a = "extended" } = {}) {
    return this.isValid ? (s ? "T" : "") + Ht(this, a === "extended", n, e, r, i) : null;
  }
  toRFC2822() {
    return xe(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
  }
  toHTTP() {
    return xe(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  toSQLDate() {
    return this.isValid ? tt(this, !0) : null;
  }
  toSQLTime({ includeOffset: e = !0, includeZone: n = !1, includeOffsetSpace: r = !0 } = {}) {
    let s = "HH:mm:ss.SSS";
    return (n || e) && (r && (s += " "), n ? s += "z" : e && (s += "ZZ")), xe(this, s, !0);
  }
  toSQL(e = {}) {
    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(e)}` : null;
  }
  toString() {
    return this.isValid ? this.toISO() : Ke;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }` : `DateTime { Invalid, reason: ${this.invalidReason} }`;
  }
  valueOf() {
    return this.toMillis();
  }
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  toJSON() {
    return this.toISO();
  }
  toBSON() {
    return this.toJSDate();
  }
  toObject(e = {}) {
    if (!this.isValid) return {};
    let n = f({}, this.c);
    return e.includeConfig && (n.outputCalendar = this.outputCalendar, n.numberingSystem = this.loc.numberingSystem, n.locale = this.loc.locale), n;
  }
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  diff(e, n = "milliseconds", r = {}) {
    if (!this.isValid || !e.isValid) return E.invalid("created by diffing an invalid DateTime");
    let s = f({ locale: this.locale, numberingSystem: this.numberingSystem }, r), i = Yr(n).map(E.normalizeUnit), a = e.valueOf() > this.valueOf(), o = a ? this : e, l = a ? e : this, u = Js(o, l, i, s);
    return a ? u.negate() : u;
  }
  diffNow(e = "milliseconds", n = {}) {
    return this.diff(v.now(), e, n);
  }
  until(e) {
    return this.isValid ? We.fromDateTimes(this, e) : this;
  }
  hasSame(e, n, r) {
    if (!this.isValid) return !1;
    let s = e.valueOf(), i = this.setZone(e.zone, { keepLocalTime: !0 });
    return i.startOf(n, r) <= s && s <= i.endOf(n, r);
  }
  equals(e) {
    return this.isValid && e.isValid && this.valueOf() === e.valueOf() && this.zone.equals(e.zone) && this.loc.equals(e.loc);
  }
  toRelative(e = {}) {
    if (!this.isValid) return null;
    let n = e.base || v.fromObject({}, { zone: this.zone }), r = e.padding ? this < n ? -e.padding : e.padding : 0, s = ["years", "months", "days", "hours", "minutes", "seconds"], i = e.unit;
    return Array.isArray(e.unit) && (s = e.unit, i = void 0), Jt(n, this.plus(r), Z(f({}, e), { numeric: "always", units: s, unit: i }));
  }
  toRelativeCalendar(e = {}) {
    return this.isValid ? Jt(e.base || v.fromObject({}, { zone: this.zone }), this, Z(f({}, e), { numeric: "auto", units: ["years", "months", "days"], calendary: !0 })) : null;
  }
  static min(...e) {
    if (!e.every(v.isDateTime)) throw new M("min requires all arguments be DateTimes");
    return Vt(e, (n) => n.valueOf(), Math.min);
  }
  static max(...e) {
    if (!e.every(v.isDateTime)) throw new M("max requires all arguments be DateTimes");
    return Vt(e, (n) => n.valueOf(), Math.max);
  }
  static fromFormatExplain(e, n, r = {}) {
    let { locale: s = null, numberingSystem: i = null } = r, a = p.fromOpts({ locale: s, numberingSystem: i, defaultToEN: !0 });
    return Gn(a, e, n);
  }
  static fromStringExplain(e, n, r = {}) {
    return v.fromFormatExplain(e, n, r);
  }
  static buildFormatParser(e, n = {}) {
    let { locale: r = null, numberingSystem: s = null } = n, i = p.fromOpts({ locale: r, numberingSystem: s, defaultToEN: !0 });
    return new Jn(i, e);
  }
  static fromFormatParser(e, n, r = {}) {
    if (h(e) || h(n)) throw new M("fromFormatParser requires an input string and a format parser");
    let { locale: s = null, numberingSystem: i = null } = r, a = p.fromOpts({ locale: s, numberingSystem: i, defaultToEN: !0 });
    if (!a.equals(n.locale)) throw new M(`fromFormatParser called with a locale of ${a}, but the format parser was created for ${n.locale}`);
    let { result: o, zone: l, specificOffset: u, invalidReason: d } = n.explainFromTokens(e);
    return d ? v.invalid(d) : X(o, l, r, `format ${n.format}`, e, u);
  }
  static get DATE_SHORT() {
    return je;
  }
  static get DATE_MED() {
    return Qt;
  }
  static get DATE_MED_WITH_WEEKDAY() {
    return yr;
  }
  static get DATE_FULL() {
    return Kt;
  }
  static get DATE_HUGE() {
    return Xt;
  }
  static get TIME_SIMPLE() {
    return en;
  }
  static get TIME_WITH_SECONDS() {
    return tn;
  }
  static get TIME_WITH_SHORT_OFFSET() {
    return nn;
  }
  static get TIME_WITH_LONG_OFFSET() {
    return rn;
  }
  static get TIME_24_SIMPLE() {
    return sn;
  }
  static get TIME_24_WITH_SECONDS() {
    return an;
  }
  static get TIME_24_WITH_SHORT_OFFSET() {
    return on;
  }
  static get TIME_24_WITH_LONG_OFFSET() {
    return ln;
  }
  static get DATETIME_SHORT() {
    return un;
  }
  static get DATETIME_SHORT_WITH_SECONDS() {
    return cn;
  }
  static get DATETIME_MED() {
    return dn;
  }
  static get DATETIME_MED_WITH_SECONDS() {
    return hn;
  }
  static get DATETIME_MED_WITH_WEEKDAY() {
    return gr;
  }
  static get DATETIME_FULL() {
    return mn;
  }
  static get DATETIME_FULL_WITH_SECONDS() {
    return fn;
  }
  static get DATETIME_HUGE() {
    return yn;
  }
  static get DATETIME_HUGE_WITH_SECONDS() {
    return gn;
  }
};
function fe(t) {
  if (b.isDateTime(t)) return t;
  if (t && t.valueOf && R(t.valueOf())) return b.fromJSDate(t);
  if (t && typeof t == "object") return b.fromObject(t);
  throw new M(`Unknown datetime argument: ${t}, of type ${typeof t}`);
}
var Xn = ur(cr), mi = [Xn.styles, or], Ve = class extends Xn {
  constructor() {
    super(), this.unselectAnnotationEsc = (t) => {
      t.key === "Escape" && (this.isSelected = !1);
    }, this.unselectAnnotation = () => {
      this.isSelected = !1;
    }, this.selectAnnotation = ({ detail: t }) => {
      let { uuid: e } = t;
      if (this.isSelected) {
        this.isSelected = !1;
        return;
      }
      this.isSelected = e === this.annotationId;
    }, this.updateComment = ({ detail: t }) => {
      let { text: e, mentions: n } = t;
      this.text = e, this.closeEditMode(), this.emitEvent("update-comment", { uuid: this.uuid, mentions: n, text: e });
    }, this.resolveAnnotation = (t) => {
      t.stopPropagation(), this.emitEvent("resolve-annotation", { type: "resolve-annotation", resolved: !this.resolved }, { composed: !1, bubbles: !1 });
    }, this.confirmDelete = () => {
      if (this.deleteCommentModalOpen = !1, this.primaryComment) return this.emitEvent("delete-annotation", { uuid: this.annotationId });
      this.emitEvent("delete-comment", { annotationId: this.annotationId, uuid: this.uuid });
    }, this.closeEditMode = () => {
      this.mode = "readonly", this.emitEvent("edit-comment", { editing: !1 });
    }, this.resolved = !1;
  }
  firstUpdated(t) {
    super.firstUpdated(t), this.updateComplete.then(() => {
      lr.call(this, ["comments"]);
    }), document.body.addEventListener("select-annotation", this.selectAnnotation);
  }
  connectedCallback() {
    super.connectedCallback(), window.document.body.addEventListener("select-annotation", this.selectAnnotation), window.document.body.addEventListener("keyup", this.unselectAnnotationEsc), window.document.body.addEventListener("unselect-annotation", this.unselectAnnotation);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.document.body.removeEventListener("select-annotation", this.selectAnnotation), window.document.body.removeEventListener("keyup", this.unselectAnnotationEsc), window.document.body.removeEventListener("unselect-annotation", this.unselectAnnotation);
  }
  getAvatar() {
    var t;
    return this.avatar ? me` <div class=${this.getClasses("avatar-container")}>
        <img src=${this.avatar} class=${this.getClasses("avatar-image")} />
      </div>` : me`<div class=${this.getClasses("avatar-container")}>
      <p class="text text-bold ${this.getClasses("avatar-letter")}">
        ${((t = this.username[0]) == null ? void 0 : t.toUpperCase()) || "A"}
      </p>
    </div>`;
  }
  getClasses(t) {
    return `comments__comment-item__${t} ${this.class}__${t}`;
  }
  render() {
    let t = this.annotationFilter === "All comments" ? "resolve" : "undo", e = (d) => b.fromISO(d).toFormat("yyyy-dd-MM"), n = this.resolvable ? "comments__comment-item__resolve" : "hidden", r = [{ label: "EDIT" }, { label: "DELETE" }], s = ({ detail: { label: d } }) => {
      d === "EDIT" && (this.mode = "editable", this.emitEvent("edit-comment", { editing: !0 })), d === "DELETE" && (this.deleteCommentModalOpen = !0);
    }, i = () => {
      let d = { "comments__comment-item--editable": !0, "hide-edit-input": this.mode !== "editable" };
      return me`
        <superviz-comments-comment-input
          class="${De(d)}"
          editable
          mode=${this.mode}
          @click=${(y) => y.stopPropagation()}
          text=${this.text}
          eventType="update-comment"
          participantsList=${JSON.stringify(this.participantsList)}
          mentions=${JSON.stringify(this.mentions)}
          @update-comment=${this.updateComment}
          @close-edit-mode=${this.closeEditMode}
        ></superviz-comments-comment-input>
      `;
    }, a = () => {
      let d = { text: !0, "text-big": !0, "sv-gray-700": !0, "annotation-content": !0, [this.getClasses("content")]: !0, editing: this.mode === "editable", "line-clamp": !this.isSelected && this.text.length > 120 };
      return me` <p id="comment-text" class="${De(d)}">${this.text}</p> `;
    }, o = () => {
      this.deleteCommentModalOpen = !1;
    }, l = { [this.class]: !0, "comments__comment-item": !0, reply: !this.primaryComment }, u = { "comments__comment-item__content__body": !0, "editing-annotation": this.mode === "editable" };
    return me`
      <div class=${De(l)}>
        <div class=${this.getClasses("header")}>
          <div class=${this.getClasses("metadata")}>
            ${this.getAvatar()}
            <span class="text text-big text-bold sv-gray-700 ${this.getClasses("username")}">
              ${this.username}
            </span>
            <span class="text text-small sv-gray-500 ${this.getClasses("date")}">
              ${e(this.createdAt)}
            </span>
          </div>
          <div class=${this.getClasses("actions")}>
            <button
              @click=${this.resolveAnnotation}
              class="${this.getClasses("icons")} ${this.getClasses("resolve-icon")} icon-button icon-button--clickable icon-button--xsmall ${n}"
            >
              <!-- TODO: Add undo icon in sm format -->
              <superviz-icon name=${t} size="sm"></superviz-icon>
            </button>
            <superviz-dropdown
              options=${JSON.stringify(r)}
              position="bottom-left"
              @selected=${s}
              @click=${(d) => {
      d.stopPropagation();
    }}
              classesPrefix="comments__dropdown"
              parentComponent="comments"
            >
              <button
                slot="dropdown"
                class="${this.getClasses("icons")} ${this.getClasses("options-icon")} icon-button icon-button--clickable icon-button--small"
              >
                <superviz-icon name="more" size="sm"></superviz-icon>
              </button>
            </superviz-dropdown>
          </div>
        </div>

        <div class="comments__comment-item__content">
          <div class="${De(u)}">${i()} ${a()}</div>
        </div>
      </div>
      <superviz-comments-delete-comments-modal
        ?open=${this.deleteCommentModalOpen}
        @close=${o}
        @confirm=${this.confirmDelete}
      >
      </superviz-comments-delete-comments-modal>
    `;
  }
};
Ve.styles = mi, Ve.properties = { uuid: { type: String }, annotationId: { type: String }, avatar: { type: String }, username: { type: String }, text: { type: String }, resolved: { type: Boolean }, resolvable: { type: Boolean }, createdAt: { type: String }, mode: { type: String }, deleteCommentModalOpen: { type: Boolean }, primaryComment: { type: Boolean }, isSelected: { type: Boolean }, annotationFilter: { type: String }, participantsList: { type: Object }, mentions: { type: Array }, class: { type: String } }, Ve = ir([dr("superviz-comments-comment-item")], Ve);
export {
  Ve as CommentsCommentItem
};
