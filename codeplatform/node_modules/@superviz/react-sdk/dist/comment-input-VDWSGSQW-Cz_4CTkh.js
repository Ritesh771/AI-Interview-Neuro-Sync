import { y as h, A as C, e as I } from "./index-CtPfqlcy.js";
import { u as v } from "./chunk-K5TMEGOR-DaSvC8Mu.js";
import "./chunk-3MEZQQ2J-CHe_tQrN.js";
import { s as x } from "./chunk-SDMTFDEM-n5DHnLs2.js";
import { n as k } from "./chunk-6U6BYUHV-TZ4JwLT4.js";
import { D as L } from "./chunk-MVFOLHBC-BeDRo2V6.js";
import { V as u, a as E, t as H } from "./chunk-WG46WHJF-JdNs68CV.js";
h();
h();
var S = class {
  constructor() {
    this.keys = ["@"], this.input = null, this.mentions = [];
  }
  setInput(t) {
    this.event = t, this.input = t.target, this.key = t.data;
  }
  getMentions(t, e = []) {
    return e.length > 0 && (this.mentions = e), this.mentions.filter((i) => ((n, s) => s.includes(n.name))(i, t));
  }
  setMentions(t) {
    this.mentions = t;
  }
  addMention(t) {
    this.mentions.some((e) => e.userId === t.userId) || this.mentions.push(t);
  }
  clearMentions() {
    this.mentions = [];
  }
  getSelectionPosition() {
    var t;
    let e = this.getSelectionStart(), i = this.getLastKeyBeforeCaret(e);
    return { start: ((t = i == null ? void 0 : i.keyIndex) != null ? t : -1) + 1, end: e };
  }
  getSelectionStart() {
    var t;
    return (t = this.input) == null ? void 0 : t.selectionStart;
  }
  setCaretPosition(t) {
    this.input.selectionEnd = t;
  }
  getValue() {
    var t;
    return (t = this.input) == null ? void 0 : t.value;
  }
  setValue(t) {
    this.input.value = t;
  }
  getLastKeyBeforeCaret(t) {
    let [e] = this.keys.map((i) => ({ key: i, keyIndex: this.getValue().lastIndexOf(i, t - 1) })).sort((i, n) => n.keyIndex - i.keyIndex);
    return e;
  }
  searchMention(t, e) {
    return e !== -1 ? this.getValue().substring(e + 1, t) : null;
  }
  isDeletion() {
    return this.event.inputType === "deleteContentBackward" || this.event.inputType === "deleteContentForward" || this.event.inputType === "deleteWordBackward";
  }
  insertMention(t, e, i) {
    if (this.isDeletion()) return;
    let { id: n, name: s } = i, o = `${this.getValue().slice(0, t) + s} ${this.getValue().slice(e, this.getValue().length)}`;
    this.setValue(o), this.input.focus(), this.addMention({ userId: n, name: s }), this.setCaretPosition(t + s.length + 1);
  }
};
h();
var c = { SHOW: "show", HIDE: "hide" }, w = { action: c.HIDE, mentions: [], findDigitParticipant: !1 }, B = (t, e, i) => {
  var n, s;
  let o = [];
  if (o = i == null ? void 0 : i.filter((a) => a == null ? void 0 : a.email), t.length > 0 && (o = o.filter((a) => (a == null ? void 0 : a.name.toLowerCase().search(t.toLowerCase())) !== -1), t === ((s = (n = o[0]) == null ? void 0 : n.name) == null ? void 0 : s.toLowerCase()))) {
    let a = b(o, e);
    return { action: c.HIDE, mentions: a, findDigitParticipant: !0 };
  }
  if (!((o == null ? void 0 : o.length) > 0)) return w;
  let l = b(o, e);
  return { action: c.SHOW, mentions: l, findDigitParticipant: !1 };
}, b = (t, e) => t.map((i) => ({ id: i.id, name: i.name, avatar: i.avatar, email: i.email, position: e })), $ = { matchParticipant: (t, e, i) => B(t, e, i) }, _ = L(E), T = [_.styles, x], r = class extends _ {
  constructor() {
    super(), this.pinCoordinates = null, this.autoCompleteHandler = new S(), this.addAtSymbolInCaretPosition = () => {
      let t = this.shadowRoot.querySelector(".comments__input__textarea"), e = new InputEvent("input", { bubbles: !0, cancelable: !0 });
      Object.defineProperty(e, "data", { value: "@", writable: !0 }), t.dispatchEvent(e);
    }, this.getCommentInput = () => this.shadowRoot.querySelector(".comments__input__textarea"), this.userMentionedByTextInput = (t) => {
      this.mentionList = [];
      let e = { detail: C({}, t[0]) };
      this.insertMention(e);
    }, this.buttonAtSymbol = () => {
      var t;
      let e = this.autoCompleteHandler.getSelectionStart(), i = this.autoCompleteHandler.getValue();
      this.autoCompleteHandler.setValue(`${i.slice(0, e)}@${i.slice(e, i.length)}`), e += 1;
      let n = this.autoCompleteHandler.getLastKeyBeforeCaret(e), s = (t = n == null ? void 0 : n.keyIndex) != null ? t : -1, o = this.autoCompleteHandler.searchMention(e, s), l = { start: s + 1, end: e };
      return { searchText: o, position: l };
    }, this.focusInput = () => {
      this.getCommentInput().focus();
    }, this.handleInput = (t) => {
      var e, i;
      ((e = this.commentInput) == null ? void 0 : e.value.length) === 0 ? this.btnActive = !1 : this.btnActive = !0, this.autoCompleteHandler.setInput(t);
      let n = this.autoCompleteHandler.getSelectionStart(), s = this.autoCompleteHandler.getLastKeyBeforeCaret(n), o = (i = s == null ? void 0 : s.keyIndex) != null ? i : -1;
      if (n === -1) return;
      let l = this.autoCompleteHandler.searchMention(n, o), a = this.autoCompleteHandler.getSelectionPosition(), g = t.data === "@" && o === -1, y = t.data === "@" && n - 1 !== o;
      if (g || y) {
        let p = this.buttonAtSymbol();
        l = p.searchText, a = p.position;
      }
      if (l === null) {
        this.mentionList = [];
        return;
      }
      let { action: d, mentions: m, findDigitParticipant: f } = $.matchParticipant(l, a, this.participantsList);
      if (f) {
        this.userMentionedByTextInput(m);
        return;
      }
      d === "show" && (this.mentionList = m), d === "hide" && (this.mentionList = []);
    }, this.insertMention = (t) => {
      let { id: e, name: i, avatar: n, email: s, position: o } = t.detail;
      this.autoCompleteHandler.insertMention(o.start, o.end, { id: e, name: i, avatar: n, email: s }), this.mentionList = [], this.updateHeight();
    }, this.sendEnter = (t) => {
      var e;
      if (t.key !== "Escape" && t.stopImmediatePropagation(), t.key === "Enter" && !t.shiftKey && t.preventDefault(), t.key !== "Enter" || t.shiftKey || ((e = this.mentionList) == null ? void 0 : e.length) > 0) return;
      let i = this.commentInput, n = i.value.trim();
      if (!n) return;
      let s = this.autoCompleteHandler.getMentions(n);
      this.emitEvent(this.eventType, { text: n, mentions: s, position: this.pinCoordinates }, { composed: !1, bubbles: !1 }), i.value = "", this.sendBtn.disabled = !0, this.updateHeight();
    }, this.closeEditMode = () => {
      this.emitEvent("close-edit-mode", {}, { composed: !1, bubbles: !1 }), this.hideInput = !0;
    }, this.onTextareaFocus = () => {
      let t = this.optionsContainer, e = this.horizontalRule, i = this.commentInput;
      t.classList.add("active-textarea"), e.classList.add("comments__input__divisor"), i.classList.add("active-textarea");
    }, this.onTextareaLoseFocus = (t) => {
      var e, i;
      let n = (i = (e = t.explicitOriginalTarget) == null ? void 0 : e.parentNode) == null ? void 0 : i.host, s = this.mentionButton;
      if (s === t.explicitOriginalTarget || s === t.relatedTarget) return;
      if (this.closeButton.contains(n) || this.closeButton.contains(t.explicitOriginalTarget) || this.closeButton.contains(t.relatedTarget)) {
        this.cancelComment();
        return;
      }
      if (!this.shadowRoot.contains(t.target)) return;
      let o = this.optionsContainer, l = this.horizontalRule, a = this.commentInput;
      a.value.length || (o.classList.remove("active-textarea"), l.classList.remove("comments__input__divisor"), a.classList.remove("active-textarea"));
    }, this.cancelComment = () => {
      document.body.dispatchEvent(new KeyboardEvent("keyup", { key: "Escape" }));
    }, this.commentInputEditableOptions = () => {
      var t;
      if (this.editable) return u`
      <button
        id="close"
        @click=${this.closeEditMode}
        class="icon-button icon-button--medium icon-button--clickable comments__input__button comments__input__close-button"
      >
        <superviz-icon name="close" size="sm"></superviz-icon>
      </button>
      <button
        id="confirm"
        class="icon-button icon-button--medium icon-button--clickable icon-button--no-hover comments__input__button comments__input__send-button"
        disabled
        @click=${this.send}
      >
        <superviz-icon
          color=${(t = this.sendBtn) != null && t.disabled || !this.sendBtn ? "black" : "white"}
          name="check"
          size="sm"
        ></superviz-icon>
      </button>
    `;
    }, this.commentInputOptions = () => {
      var t;
      if (!this.editable) return u`
      <button
        class="icon-button icon-button--medium icon-button--clickable comments__input__button comments__input__close-button align-send-btn"
        @click=${this.cancelComment}
      >
        <superviz-icon name="close" size="sm"></superviz-icon>
      </button>
      <button
        class="comments__input__button comments__input__send-button align-send-btn"
        disabled
        @click=${this.send}
      >
        <superviz-icon
          color=${(t = this.sendBtn) != null && t.disabled || !this.sendBtn ? "black" : "white"}
          name="line-arrow-right"
          size="sm"
        ></superviz-icon>
      </button>
    `;
    }, this.btnActive = !1, this.text = "", this.mentionList = [], this.mentions = [], this.mode = "readonly";
  }
  get commentInput() {
    return this.shadowRoot.querySelector(".comments__input__textarea");
  }
  get mentionButton() {
    return this.shadowRoot.querySelector(".mention-button");
  }
  get sendBtn() {
    return this.shadowRoot.querySelector(".comments__input__send-button");
  }
  get optionsContainer() {
    return this.shadowRoot.querySelector(".comments__input__options");
  }
  get horizontalRule() {
    return this.shadowRoot.querySelector(".sv-hr");
  }
  get closeButton() {
    return this.shadowRoot.querySelector(".comments__input__close-button");
  }
  connectedCallback() {
    super.connectedCallback(), ["create-annotation", "create-comment"].includes(this.eventType) && this.addEventListener("keyup", this.sendEnter);
  }
  disconnectedCallback() {
    if (super.disconnectedCallback(), !["create-annotation", "create-comment"].includes(this.eventType)) return;
    let t = this.getCommentInput();
    this.removeEventListener("keyup", this.sendEnter), t.removeEventListener("keydown", this.sendEnter), t.removeEventListener("click", this.focusInput), t.addEventListener("input", this.handleInput);
  }
  firstUpdated(t) {
    this.updateComplete.then(() => {
      this.emitEvent("comment-input-ready", {}, { composed: !1, bubbles: !1 });
      let e = this.getCommentInput();
      if (e && (e.addEventListener("input", this.handleInput), e.addEventListener("click", this.focusInput), e.addEventListener("keydown", this.sendEnter)), this.text.length > 0) {
        let i = this.participantsList.map(({ id: n, name: s }) => ({ userId: n, name: s }));
        this.mentions = this.autoCompleteHandler.getMentions(this.text, i), this.autoCompleteHandler.setMentions(this.mentions);
      }
      this.editable && this.focusInput(), k.call(this, ["comments"]);
    });
  }
  updated(t) {
    if (t.has("mode") && this.mode === "editable" && (this.focusInput(), this.updateHeight(), this.sendBtn.disabled = !1, this.btnActive = !0), t.has("text") && this.text.length > 0) {
      let e = this.commentInput;
      e.value = this.text, this.updateHeight();
    }
    t.has("btnActive") && (this.sendBtn.disabled = !this.btnActive);
  }
  updateHeight() {
    let t = this.commentInput;
    t.style.height = "40px";
    let e = t.scrollHeight + 14;
    e === 47 && (e = 40), t.style.height = `${e}px`, this.sendBtn.disabled = !(t.value.length > 0);
  }
  send(t) {
    var e;
    if (t.preventDefault(), ((e = this.mentionList) == null ? void 0 : e.length) > 0) return;
    let i = this.commentInput, n = i.value, s = this.autoCompleteHandler.getMentions(n);
    this.emitEvent(this.eventType, { text: n, mentions: s, position: this.pinCoordinates }, { composed: !1, bubbles: !1 }), i.value = "", this.sendBtn.disabled = !0, this.updateHeight();
  }
  render() {
    var t;
    let e = { comments__input__textarea: !0, "fixed-width": this.eventType === "create-annotation" }, i = { comments__input: !0, "comments__input--editable": this.editable, "hide-input": this.hideInput };
    return u`
      <div class="${v(i)}">
        <textarea
          id="comments__input__textarea"
          class=${v(e)}
          placeholder=${(t = this.placeholder) != null ? t : "Add comment..."}
          @input=${this.updateHeight}
          @focus=${this.onTextareaFocus}
          @blur=${this.onTextareaLoseFocus}
          spellcheck="false"
        ></textarea>
        <superviz-comments-mention-list
          .participants=${this.mentionList}
          @participant-selected=${this.insertMention}
        ></superviz-comments-mention-list>
        <div class="sv-hr"></div>
        <div class="comments__input__options">
          <button
            @click=${this.addAtSymbolInCaretPosition}
            class="mention-button icon-button icon-button--medium icon-button--clickable"
          >
            <superviz-icon name="mention" size="sm"></superviz-icon>
          </button>
          <div class="comment-input-options">
            ${this.commentInputOptions()} ${this.commentInputEditableOptions()}
          </div>
        </div>
      </div>
    `;
  }
};
r.styles = T, r.properties = { eventType: { type: String }, text: { type: String }, btnActive: { type: Boolean }, editable: { type: Boolean }, placeholder: { type: String }, mentions: { type: Array }, mentionList: { type: Object }, participantsList: { type: Object }, hideInput: { type: Boolean }, mode: { type: String } }, r = I([H("superviz-comments-comment-input")], r);
export {
  r as CommentsCommentInput
};
