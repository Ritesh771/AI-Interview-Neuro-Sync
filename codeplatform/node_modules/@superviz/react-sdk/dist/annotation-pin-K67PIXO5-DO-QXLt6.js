import { y as d, g as l, A as r, e as m } from "./index-CtPfqlcy.js";
import { u as p } from "./chunk-K5TMEGOR-DaSvC8Mu.js";
import "./chunk-3MEZQQ2J-CHe_tQrN.js";
import { c as h } from "./chunk-SDMTFDEM-n5DHnLs2.js";
import { n as u } from "./chunk-6U6BYUHV-TZ4JwLT4.js";
import { D as v } from "./chunk-MVFOLHBC-BeDRo2V6.js";
import { V as e, a as y, t as S } from "./chunk-WG46WHJF-JdNs68CV.js";
d();
var c = v(y), _ = [c.styles, h], s = class extends c {
  constructor() {
    super(), this.focusInput = () => {
      var t, n;
      this.inputElement || (this.inputElement = (n = (t = this.shadowRoot) == null ? void 0 : t.querySelector("superviz-comments-comment-input")) == null ? void 0 : n.shadowRoot.querySelector("textarea")), this.inputElement.focus();
    }, this.setInputSide = () => {
      let t = this.commentsSide === "right" ? 320 : 0, n = this.annotationSides.right + 293, i = this.containerSides.right - t;
      if (n < i) {
        this.horizontalSide = "right";
        return;
      }
      t = this.commentsSide === "left" ? 320 : 0;
      let o = this.annotationSides.left - 293, a = this.containerSides.left + t;
      if (o > a) {
        this.horizontalSide = "left";
        return;
      }
      this.horizontalSide = a - o > n - i ? "right" : "left";
    }, this.createComment = ({ detail: t }) => {
      this.annotationSent = !0, document.body.dispatchEvent(new CustomEvent("create-annotation", { detail: l(r({}, t), { position: l(r({}, this.originalPosition), { type: "canvas" }) }) })), this.annotation = null;
    }, this.cancelTemporaryAnnotation = () => {
      this.annotation = null;
    }, this.cancelTemporaryAnnotationEsc = (t) => {
      this.annotation = null;
    }, this.avatar = () => {
      if (this.type === "add" && !this.showInput) return e`<div
        class="comments__annotation-pin__avatar comments__annotation-pin__avatar--add"
      >
        <superviz-icon name="add"></superviz-icon>
      </div>`;
      let t = this.userAvatar;
      return t ? e`<div class="comments__annotation-pin__avatar">
        <img src=${t} />
      </div>` : e`<div class="comments__annotation-pin__avatar">
      <p class="text text-bold text-big">${this.userInitial}</p>
    </div>`;
    }, this.input = () => {
      if (!(!this.showInput || this.annotationSent)) return e`<div class="floating-input">
      <superviz-comments-comment-input
        @create-annotation=${this.createComment}
        eventType="create-annotation"
        @comment-input-ready=${this.focusInput}
        participantsList=${JSON.stringify(this.participantsList)}
      >
      </superviz-comments-comment-input>
    </div>`;
    }, this.position = { x: 0, y: 0 }, setTimeout(() => {
      this.firstLoad = !1;
    }, 800);
  }
  updated(t) {
    super.updated(t), !(!t.has("movedPosition") || !this.annotationSides) && (this.annotationSides = this.pinAnnotation.getBoundingClientRect(), this.setInputSide(), this.inputElement && this.focusInput());
  }
  firstUpdated(t) {
    var n;
    super.firstUpdated(t), u.call(this, ["comments"]), this.showInput && (this.originalPosition = r({}, this.position), this.pinAnnotation = (n = this.shadowRoot) == null ? void 0 : n.querySelector(".comments__annotation-pin"), this.annotationSides = this.pinAnnotation.getBoundingClientRect(), this.setInputSide());
  }
  connectedCallback() {
    if (super.connectedCallback(), this.type !== "add") return;
    let { localParticipant: t } = this.useStore("global-store");
    t.subscribe((n) => {
      var i;
      this.localAvatar = (i = n == null ? void 0 : n.avatar) == null ? void 0 : i.imageUrl, this.localName = n == null ? void 0 : n.name;
    }), window.document.body.addEventListener("close-temporary-annotation", this.cancelTemporaryAnnotation), window.document.body.addEventListener("keyup", (n) => {
      n.key === "Escape" && this.cancelTemporaryAnnotationEsc(n);
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.type === "add" && (window.document.body.removeEventListener("close-temporary-annotation", this.cancelTemporaryAnnotation), window.document.body.removeEventListener("keyup", (t) => {
      t.key === "Escape" && this.cancelTemporaryAnnotationEsc(t);
    }));
  }
  get userAvatar() {
    var t, n, i, o;
    return ((o = (i = (n = (t = this.annotation) == null ? void 0 : t.comments) == null ? void 0 : n.at(0)) == null ? void 0 : i.participant) == null ? void 0 : o.avatar) || this.localAvatar;
  }
  get userInitial() {
    var t, n, i, o, a;
    return (((a = (o = (i = (n = (t = this.annotation) == null ? void 0 : t.comments) == null ? void 0 : n.at(0)) == null ? void 0 : i.participant) == null ? void 0 : o.name) != null ? a : this.localName) || "Anonymous")[0].toUpperCase();
  }
  emitClick() {
    var t;
    document.body.dispatchEvent(new CustomEvent("select-annotation", { detail: { uuid: (t = this.annotation) == null ? void 0 : t.uuid } }));
  }
  render() {
    let t = { "comments__annotation-pin": !0, preload: this.firstLoad === void 0, "comments__annotation-pin--active": this.active, "comments__cursor-pointer": this.type === "add" && !this.showInput, "comments__annotation-pin--add": this.type === "add" && this.showInput, [this.horizontalSide]: !0 }, n = { "comments__annotation-pin-wrapper": !0, "comments__annotation-pin-wrapper--new": this.newPin }, i = this.keepPositionRatio ? "%" : "px", o = `top: ${this.position.y}${i}; left: ${this.position.x}${i};`;
    return this.type === "add" ? e`
        <div class=${p(t)} style=${o}>${this.avatar()} ${this.input()}</div>
      ` : e`<div class=${p(n)} style=${o}>
      <div @click=${this.emitClick} class=${p(t)}>${this.avatar()}</div>
    </div> `;
  }
};
s.styles = _, s.properties = { type: { type: String }, annotation: { type: Object }, position: { type: Object }, active: { type: Boolean }, showInput: { type: Boolean }, containerSides: { type: Object }, horizontalSide: { type: String }, commentsSide: { type: String }, movedPosition: { type: String }, pinAnnotation: { type: Object }, localAvatar: { type: String }, annotationSent: { type: Boolean }, localName: { type: String }, keepPositionRatio: { type: Boolean }, participantsList: { type: Object }, firstLoad: { type: Boolean }, newPin: { type: Boolean } }, s = m([S("superviz-comments-annotation-pin")], s);
export {
  s as CommentsAnnotationPin
};
