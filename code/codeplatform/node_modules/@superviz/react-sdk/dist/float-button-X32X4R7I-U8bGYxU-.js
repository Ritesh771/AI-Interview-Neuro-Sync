import { u as i } from "./chunk-K5TMEGOR-DaSvC8Mu.js";
import "./chunk-3MEZQQ2J-CHe_tQrN.js";
import { d as f } from "./chunk-SDMTFDEM-n5DHnLs2.js";
import { n as x } from "./chunk-6U6BYUHV-TZ4JwLT4.js";
import { D as y } from "./chunk-MVFOLHBC-BeDRo2V6.js";
import { V as _, a as H, t as w } from "./chunk-WG46WHJF-JdNs68CV.js";
import { y as A, e as C } from "./index-CtPfqlcy.js";
A();
var h = y(H), S = [h.styles, f], s = class extends h {
  constructor() {
    super(), this.onTogglePinActive = ({ detail: { isActive: e } }) => {
      this.isActive = e;
    }, this.isHidden = !0, this.positionStyles = "top: 20px; left: 20px;", this.shouldHide = !1, this.commentsPosition = "left";
  }
  firstUpdated(e) {
    super.firstUpdated(e), this.updateComplete.then(() => {
      x.call(this, ["comments"]);
    }), this.mouseHovering = !1;
    let t = this.shadowRoot.querySelector(".comments__floating-button");
    t.addEventListener("mouseenter", () => {
      setTimeout(() => t.classList.add("comments-floating-button-hovered"), 300), this.mouseHovering = !0;
    }), t.addEventListener("mouseleave", () => {
      t.classList.remove("comments-floating-button-hovered"), this.mouseHovering = !1;
    });
  }
  toggle() {
    this.emitEvent("toggle", {});
  }
  connectedCallback() {
    super.connectedCallback(), window.document.body.addEventListener("toggle-annotation-sidebar", () => {
      this.isHidden = !this.isHidden;
    }), window.document.body.addEventListener("toggle-pin-active", this.onTogglePinActive);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.document.body.removeEventListener("toggle-annotation-sidebar", () => {
      this.isHidden = !this.isHidden;
    }), window.document.body.removeEventListener("toggle-pin-active", this.onTogglePinActive);
  }
  updated(e) {
    super.updated(e), this.updateComplete.then(() => {
      let t = this.shadowRoot.querySelector(".comments__floating-button");
      t && t.setAttribute("style", this.positionStyles);
    });
  }
  calculateIfShouldHide() {
    var e;
    let t = (e = document.getElementsByTagName("superviz-comments")[0]) == null ? void 0 : e.shadowRoot.querySelector(".superviz-comments"), o = this.shadowRoot.querySelector(".comments__floating-button");
    if (!t || !o) return;
    let { left: n, right: c, top: d, bottom: l } = t.getBoundingClientRect(), { left: a, right: r, top: m, bottom: u } = o.getBoundingClientRect(), v = l > m && u > d, g = d < u && m < l, p = c > a && r > n, b = n < r && a < c;
    this.shouldHide = (g || v) && (p || b);
  }
  render() {
    this.calculateIfShouldHide();
    let e = { "comments__floating-button": !0, "hide-button": !this.isHidden && this.shouldHide, "is-active": this.isActive, "is-inactive": !this.isActive }, t = { "comments__floating-button-text-box": !0, "comments__floating-button-text-box--hovered": this.mouseHovering }, o = { text: !0, "text-big": !0, "text-bold": !0, "not-hovered": !this.mouseHovering, "comments__floating-button__text": !0, textActive: this.isActive, textInactive: !this.isActive };
    return _` <button @click=${this.toggle} class="${i(e)}">
      <div class="comments__floating-button__icon">
        <superviz-icon
          size="sm"
          name="comment"
          color=${this.mouseHovering || this.isActive ? "white" : "black"}
        ></superviz-icon>
        <svg class="cross" width="8px" height="8px" viewBox="0 0 8 8">
          <rect class="cross-bar-1" x="0" y="3" width="8px" height="2px" />
          <rect class="cross-bar-2" x="0" y="3" width="8px" height="2px" />
        </svg>
      </div>
      <div class=${i(t)}>
        <p class="${i(o)} comment">Comment</p>
        <p class="${i(o)} cancel">Cancel</p>
      </div>
    </button>`;
  }
};
s.styles = S, s.properties = { positionStyles: { type: String }, isHidden: { type: Boolean }, commentsPosition: { type: String }, isActive: { type: Boolean }, mouseHovering: { type: Boolean } }, s = C([w("superviz-comments-button")], s);
export {
  s as CommentsFloatButton
};
