import { y as C, e as g } from "./index-CtPfqlcy.js";
import { u as s } from "./chunk-K5TMEGOR-DaSvC8Mu.js";
import "./chunk-3MEZQQ2J-CHe_tQrN.js";
import { p as y } from "./chunk-SDMTFDEM-n5DHnLs2.js";
import { n as A } from "./chunk-6U6BYUHV-TZ4JwLT4.js";
import { D as x } from "./chunk-MVFOLHBC-BeDRo2V6.js";
import { V as r, a as f, t as S } from "./chunk-WG46WHJF-JdNs68CV.js";
C();
var v = x(f), _ = [v.styles, y], d = class extends v {
  constructor() {
    super(...arguments), this.selectAnnotation = (t) => {
      let { uuid: e } = this.annotation;
      document.body.dispatchEvent(new CustomEvent("select-annotation", { detail: { uuid: e } }));
    }, this.resolveAnnotation = ({ detail: t }) => {
      let { uuid: e } = this.annotation, { resolved: n, type: i } = t, o = i === "resolve-annotation" && this.annotationFilter === "All comments";
      this.emitEvent("resolve-annotation", { uuid: e, resolved: n }), o && (this.shouldShowUndoResolved = !0);
    }, this.hideUndoResolved = () => {
      this.shouldShowUndoResolved = !1;
    }, this.generateExpandedCommentsTemplate = (t, e) => {
      var n, i, o, a;
      return e === 0 ? r`` : r`
      <superviz-comments-comment-item
        uuid=${t.uuid}
        avatar=${(a = (o = (i = (n = this.annotation) == null ? void 0 : n.comments) == null ? void 0 : i.at(e)) == null ? void 0 : o.participant) == null ? void 0 : a.avatar}
        username=${t.participant.name || "Anonymous"}
        text=${t.text}
        createdAt=${t.createdAt}
        annotationId=${this.annotation.uuid}
        participantsList=${JSON.stringify(this.participantsList)}
        mentions=${JSON.stringify(t.mentions)}
        class="comments__replies"
      ></superviz-comments-comment-item>
    `;
    }, this.updateEditMode = ({ detail: { editing: t } }) => {
      this.hideInput = t;
    };
  }
  firstUpdated(t) {
    super.firstUpdated(t), this.updateComplete.then(() => {
      A.call(this, ["comments"]);
    });
  }
  get filterIsAll() {
    return this.annotationFilter === "All comments";
  }
  get filterIsResolved() {
    return this.annotationFilter === "Resolved comments";
  }
  get shouldHideAnnotation() {
    return { hidden: this.resolved && this.filterIsAll || !this.resolved && this.filterIsResolved };
  }
  get replies() {
    return [...this.annotation.comments].splice(1).length;
  }
  get repliesSize() {
    return this.replies >= 5 ? 5 : this.replies;
  }
  get replyText() {
    return this.replies !== 1 ? "replies" : "reply";
  }
  get isSelected() {
    return this.selected === this.annotation.uuid;
  }
  get annotationClasses() {
    return { comments__thread: !0, "comments__thread--selected": this.isSelected, "extra-space-bottom": this.replies };
  }
  get mainAnnotationClasses() {
    return { "comments__main-annotation": !0, "comments__main-annotation--selected": this.isSelected };
  }
  get hrClasses() {
    return { "sv-hr": !0, hidden: this.isLastAnnotation };
  }
  get avatarCommentsClasses() {
    return { "avatars-comments": !0, "comment-avatar--expand": !this.expandComments && this.replies > 1, invisible: !(!this.expandComments && this.replies >= 1) };
  }
  get containerWrapperClasses() {
    return { "comments-container-wrapper": !0, show: this.isSelected && this.expandComments };
  }
  get commentsClasses() {
    return { "comments-container": !0, "comment-item--expand": this.isSelected && this.expandComments, show: this.isSelected && this.expandComments };
  }
  updated(t) {
    if (t.has("selected")) {
      let e = this.selected === this.annotation.uuid;
      this.expandComments = e;
    }
  }
  createComment({ detail: t }) {
    let { text: e, mentions: n } = t;
    this.emitEvent("create-comment", { uuid: this.annotation.uuid, mentions: n, text: e });
  }
  generateAvatarCommentsTemplate() {
    var t, e, n, i, o, a;
    let m = [];
    for (let l = 1; l <= this.repliesSize; l++) (e = (t = this.annotation.comments[l]) == null ? void 0 : t.participant) != null && e.avatar ? m.push(r`
          <div class="avatar">
            <img src=${(i = (n = this.annotation.comments[l]) == null ? void 0 : n.participant) == null ? void 0 : i.avatar} />
          </div>
        `) : m.push(r`
          <div class="avatar">
            <p class="text text-bold">
              ${((a = (o = this.annotation.comments[l]) == null ? void 0 : o.participant.name[0]) == null ? void 0 : a.toUpperCase()) || "A"}
            </p>
          </div>
        `);
    return r`
      ${m}
      <div class="text text-big sv-gray-500">${this.replies} ${this.replyText}</div>
    `;
  }
  annotationResolvedTemplate() {
    return this.shouldShowUndoResolved ? r`
      <superviz-comments-annotation-resolved
        @undo-resolve=${this.resolveAnnotation}
        @hide=${this.hideUndoResolved}
        class=${s({ hidden: this.filterIsResolved, "comments__resolved-annotation-message": !0 })}
      >
      </superviz-comments-annotation-resolved>
    ` : r``;
  }
  get inputClasses() {
    return { "hide-input": this.hideInput };
  }
  get wrapperClasses() {
    return { wrapper: !0, "show-wrapper": !this.resolved && this.filterIsAll || this.resolved && this.filterIsResolved };
  }
  render() {
    var t, e, n, i, o, a, m, l, p, c, h;
    let u = { "comments__complete-annotation": !0, "comments__hide-complete-annotation": this.shouldShowUndoResolved };
    return r`
      <div class="${s(u)}">
        ${this.annotationResolvedTemplate()}

        <div class=${s(this.wrapperClasses)}>
          <div class=${s(this.shouldHideAnnotation)}>
            <div class=${s(this.annotationClasses)} @click=${this.selectAnnotation}>
              <div class=${s(this.mainAnnotationClasses)}>
                <superviz-comments-comment-item
                  uuid=${(t = this.annotation.comments) == null ? void 0 : t[0].uuid}
                  annotationId=${this.annotation.uuid}
                  username=${((n = (e = this.annotation.comments) == null ? void 0 : e[0].participant) == null ? void 0 : n.name) || "Anonymous"}
                  text=${(i = this.annotation.comments) == null ? void 0 : i[0].text}
                  createdAt=${(o = this.annotation.comments) == null ? void 0 : o[0].createdAt}
                  participantsList=${JSON.stringify(this.participantsList)}
                  primaryComment
                  avatar=${(p = (l = (m = (a = this.annotation) == null ? void 0 : a.comments) == null ? void 0 : m.at(0)) == null ? void 0 : l.participant) == null ? void 0 : p.avatar}
                  resolvable
                  ?resolved=${this.resolved}
                  annotationFilter=${this.annotationFilter}
                  @resolve-annotation=${this.resolveAnnotation}
                  mentions=${JSON.stringify((c = this.annotation.comments) == null ? void 0 : c[0].mentions)}
                  class="comments__annotation"
                  @edit-comment=${this.updateEditMode}
                ></superviz-comments-comment-item>
              </div>

              <div class=${s(this.containerWrapperClasses)}>
                <div class=${s(this.commentsClasses)}>
                  ${(h = this.annotation.comments) == null ? void 0 : h.map(this.generateExpandedCommentsTemplate)}
                  <span class=${s(this.inputClasses)}>
                    <superviz-comments-comment-input
                      @create-comment=${this.createComment}
                      eventType="create-comment"
                      @click=${($) => $.stopPropagation()}
                      placeholder="Reply"
                      participantsList=${JSON.stringify(this.participantsList)}
                    ></superviz-comments-comment-input>
                  </span>
                </div>
              </div>
              <div class=${s(this.avatarCommentsClasses)}>
                <div class="avatar-container">${this.generateAvatarCommentsTemplate()}</div>
              </div>
            </div>
            <div class=${s(this.hrClasses)}></div>
          </div>
        </div>
      </div>
    `;
  }
};
d.styles = _, d.properties = { annotation: { type: Object }, expandComments: { type: Boolean }, selected: { type: String, reflect: !0 }, resolved: { type: Boolean }, shouldShowUndoResolved: { type: Boolean }, isLastAnnotation: { type: Boolean }, annotationFilter: { type: String }, participantsList: { type: Object }, hideInput: { type: Boolean } }, d = g([S("superviz-comments-annotation-item")], d);
export {
  d as CommentsAnnotationItem
};
