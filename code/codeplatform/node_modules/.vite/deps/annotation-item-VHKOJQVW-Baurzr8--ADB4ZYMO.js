import {
  c
} from "./chunk-UCISHT4U.js";
import {
  S
} from "./chunk-2LBTZ565.js";
import "./chunk-NPBUWTT3.js";
import {
  m
} from "./chunk-XBJC4IFL.js";
import {
  f
} from "./chunk-OC6HSZIE.js";
import {
  Lt,
  Mt,
  T
} from "./chunk-3CQNC6PN.js";
import {
  O,
  QA
} from "./chunk-EQC6TVAW.js";
import "./chunk-IW2W7CGS.js";
import "./chunk-LK32TJAX.js";

// node_modules/@superviz/react-sdk/dist/annotation-item-VHKOJQVW-Baurzr8-.js
O();
var v = f(T);
var _ = [v.styles, m];
var d = class extends v {
  constructor() {
    super(...arguments), this.selectAnnotation = (t) => {
      let { uuid: e } = this.annotation;
      document.body.dispatchEvent(new CustomEvent("select-annotation", { detail: { uuid: e } }));
    }, this.resolveAnnotation = ({ detail: t }) => {
      let { uuid: e } = this.annotation, { resolved: n, type: i } = t, o = i === "resolve-annotation" && this.annotationFilter === "All comments";
      this.emitEvent("resolve-annotation", { uuid: e, resolved: n }), o && (this.shouldShowUndoResolved = true);
    }, this.hideUndoResolved = () => {
      this.shouldShowUndoResolved = false;
    }, this.generateExpandedCommentsTemplate = (t, e) => {
      var n, i, o, a;
      return e === 0 ? Mt`` : Mt`
      <superviz-comments-comment-item
        uuid=${t.uuid}
        avatar=${(a = (o = (i = (n = this.annotation) == null ? void 0 : n.comments) == null ? void 0 : i.at(e)) == null ? void 0 : o.participant) == null ? void 0 : a.avatar}
        username=${t.participant.name || "Anonymous"}
        text=${t.text}
        createdAt=${t.createdAt}
        annotationId=${this.annotation.uuid}
        participantsList=${JSON.stringify(this.participantsList)}
        mentions=${JSON.stringify(t.mentions)}
        class="comments__replies"
      ></superviz-comments-comment-item>
    `;
    }, this.updateEditMode = ({ detail: { editing: t } }) => {
      this.hideInput = t;
    };
  }
  firstUpdated(t) {
    super.firstUpdated(t), this.updateComplete.then(() => {
      S.call(this, ["comments"]);
    });
  }
  get filterIsAll() {
    return this.annotationFilter === "All comments";
  }
  get filterIsResolved() {
    return this.annotationFilter === "Resolved comments";
  }
  get shouldHideAnnotation() {
    return { hidden: this.resolved && this.filterIsAll || !this.resolved && this.filterIsResolved };
  }
  get replies() {
    return [...this.annotation.comments].splice(1).length;
  }
  get repliesSize() {
    return this.replies >= 5 ? 5 : this.replies;
  }
  get replyText() {
    return this.replies !== 1 ? "replies" : "reply";
  }
  get isSelected() {
    return this.selected === this.annotation.uuid;
  }
  get annotationClasses() {
    return { comments__thread: true, "comments__thread--selected": this.isSelected, "extra-space-bottom": this.replies };
  }
  get mainAnnotationClasses() {
    return { "comments__main-annotation": true, "comments__main-annotation--selected": this.isSelected };
  }
  get hrClasses() {
    return { "sv-hr": true, hidden: this.isLastAnnotation };
  }
  get avatarCommentsClasses() {
    return { "avatars-comments": true, "comment-avatar--expand": !this.expandComments && this.replies > 1, invisible: !(!this.expandComments && this.replies >= 1) };
  }
  get containerWrapperClasses() {
    return { "comments-container-wrapper": true, show: this.isSelected && this.expandComments };
  }
  get commentsClasses() {
    return { "comments-container": true, "comment-item--expand": this.isSelected && this.expandComments, show: this.isSelected && this.expandComments };
  }
  updated(t) {
    if (t.has("selected")) {
      let e = this.selected === this.annotation.uuid;
      this.expandComments = e;
    }
  }
  createComment({ detail: t }) {
    let { text: e, mentions: n } = t;
    this.emitEvent("create-comment", { uuid: this.annotation.uuid, mentions: n, text: e });
  }
  generateAvatarCommentsTemplate() {
    var t, e, n, i, o, a;
    let m2 = [];
    for (let l = 1; l <= this.repliesSize; l++) (e = (t = this.annotation.comments[l]) == null ? void 0 : t.participant) != null && e.avatar ? m2.push(Mt`
          <div class="avatar">
            <img src=${(i = (n = this.annotation.comments[l]) == null ? void 0 : n.participant) == null ? void 0 : i.avatar} />
          </div>
        `) : m2.push(Mt`
          <div class="avatar">
            <p class="text text-bold">
              ${((a = (o = this.annotation.comments[l]) == null ? void 0 : o.participant.name[0]) == null ? void 0 : a.toUpperCase()) || "A"}
            </p>
          </div>
        `);
    return Mt`
      ${m2}
      <div class="text text-big sv-gray-500">${this.replies} ${this.replyText}</div>
    `;
  }
  annotationResolvedTemplate() {
    return this.shouldShowUndoResolved ? Mt`
      <superviz-comments-annotation-resolved
        @undo-resolve=${this.resolveAnnotation}
        @hide=${this.hideUndoResolved}
        class=${c({ hidden: this.filterIsResolved, "comments__resolved-annotation-message": true })}
      >
      </superviz-comments-annotation-resolved>
    ` : Mt``;
  }
  get inputClasses() {
    return { "hide-input": this.hideInput };
  }
  get wrapperClasses() {
    return { wrapper: true, "show-wrapper": !this.resolved && this.filterIsAll || this.resolved && this.filterIsResolved };
  }
  render() {
    var t, e, n, i, o, a, m2, l, p, c2, h;
    let u = { "comments__complete-annotation": true, "comments__hide-complete-annotation": this.shouldShowUndoResolved };
    return Mt`
      <div class="${c(u)}">
        ${this.annotationResolvedTemplate()}

        <div class=${c(this.wrapperClasses)}>
          <div class=${c(this.shouldHideAnnotation)}>
            <div class=${c(this.annotationClasses)} @click=${this.selectAnnotation}>
              <div class=${c(this.mainAnnotationClasses)}>
                <superviz-comments-comment-item
                  uuid=${(t = this.annotation.comments) == null ? void 0 : t[0].uuid}
                  annotationId=${this.annotation.uuid}
                  username=${((n = (e = this.annotation.comments) == null ? void 0 : e[0].participant) == null ? void 0 : n.name) || "Anonymous"}
                  text=${(i = this.annotation.comments) == null ? void 0 : i[0].text}
                  createdAt=${(o = this.annotation.comments) == null ? void 0 : o[0].createdAt}
                  participantsList=${JSON.stringify(this.participantsList)}
                  primaryComment
                  avatar=${(p = (l = (m2 = (a = this.annotation) == null ? void 0 : a.comments) == null ? void 0 : m2.at(0)) == null ? void 0 : l.participant) == null ? void 0 : p.avatar}
                  resolvable
                  ?resolved=${this.resolved}
                  annotationFilter=${this.annotationFilter}
                  @resolve-annotation=${this.resolveAnnotation}
                  mentions=${JSON.stringify((c2 = this.annotation.comments) == null ? void 0 : c2[0].mentions)}
                  class="comments__annotation"
                  @edit-comment=${this.updateEditMode}
                ></superviz-comments-comment-item>
              </div>

              <div class=${c(this.containerWrapperClasses)}>
                <div class=${c(this.commentsClasses)}>
                  ${(h = this.annotation.comments) == null ? void 0 : h.map(this.generateExpandedCommentsTemplate)}
                  <span class=${c(this.inputClasses)}>
                    <superviz-comments-comment-input
                      @create-comment=${this.createComment}
                      eventType="create-comment"
                      @click=${($) => $.stopPropagation()}
                      placeholder="Reply"
                      participantsList=${JSON.stringify(this.participantsList)}
                    ></superviz-comments-comment-input>
                  </span>
                </div>
              </div>
              <div class=${c(this.avatarCommentsClasses)}>
                <div class="avatar-container">${this.generateAvatarCommentsTemplate()}</div>
              </div>
            </div>
            <div class=${c(this.hrClasses)}></div>
          </div>
        </div>
      </div>
    `;
  }
};
d.styles = _, d.properties = { annotation: { type: Object }, expandComments: { type: Boolean }, selected: { type: String, reflect: true }, resolved: { type: Boolean }, shouldShowUndoResolved: { type: Boolean }, isLastAnnotation: { type: Boolean }, annotationFilter: { type: String }, participantsList: { type: Object }, hideInput: { type: Boolean } }, d = QA([Lt("superviz-comments-annotation-item")], d);
export {
  d as CommentsAnnotationItem
};
//# sourceMappingURL=annotation-item-VHKOJQVW-Baurzr8--ADB4ZYMO.js.map
